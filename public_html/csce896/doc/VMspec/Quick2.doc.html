<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>VM Spec  </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
<table width=100%><tr>
<td><a href="VMSpecTOC.doc.html">Contents</a> | <a href="Quick.doc.html">Prev</a> | <a href="Mnemonics.doc.html">Next</a> | <a href="Lindholm.INDEX.html">Index</a></td><td align=right><i><i>The Java<sup><font size=-2>TM</font></sup> Virtual Machine Specification</i></i></td>
</tr></table>


<hr><br>
 

<a name="anewarray_quick"></a>
<h2>anewarray_quick</h2>
<a name="anewarray_quick.Operation"></a>
<b>Operation</h3></b>
<a name="12436"></a>
Create new array<p><Table Border="1">
<tr><td><a name="12431"></a>
 <i>anewarray_quick</i>
<td><a name="26"></a>
 

<tr><td><a name="12433"></a>
 <i>indexbyte1</i>
<td><a name="33"></a>
 

<tr><td><a name="12435"></a>
 <i>indexbyte2</i>
<td><a name="40"></a>
 

</Table><br><br> of <code>reference</code><p>
<a name="anewarray_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12441"></a>
<i>anewarray_quick</i> = 222 (0xde)<p>
<a name="anewarray_quick.Stack"></a>
<b>Stack</h3></b>
<a name="12438"></a>
 ..., <i>count</i><em> </em><img src="chars/arrwdbrt.gif">  ..., <i>arrayref</i><p>
<a name="anewarray_quick.Description"></a>
<b>Description</h3></b>
<a name="20629"></a>
The <i>count</i> must be of type <code>int</code>. It is popped off the operand stack. The <i>count</i> represents the number of components of the array to be created. The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The item at that index in the constant pool must already have been successfully resolved and must be a class or interface type. A new array of that type, of length <i>count</i>, is allocated from the garbage-collected heap, and a <code>reference</code> <i>arrayref</i> to this new array object is pushed onto the operand stack. All components of the new array are initialized to <code>null</code>, the default value for reference types <a href="Concepts.doc.html#15858">(&#167;2.5.1)</a>.<p>
<a name="anewarray_quick.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="12060"></a>
If <i>count</i> is less than zero, the <i>anewarray_quick</i> instruction throws a <code>NegativeArraySizeException</code>.<p>
<a name="anewarray_quick.Notes"></a>
<b>Notes</h3></b>
<a name="5062"></a>
The opcode of this instruction was originally <i>anewarray</i>. The operands of the <i>anewarray</i> instruction are not modified.<p>
<a name="8220"></a>
The<i> anewarray_quick</i> instruction is used to create a single dimension of an array of object references. It can also be used to create the first dimension of a multidimensional array.<p>

<a name="checkcast_quick"></a>
<hr><h2>checkcast_quick</h2>
<a name="checkcast_quick.Operation"></a>
<b>Operation</h3></b>
<a name="5287"></a>
Check whether object is of given type<p><Table Border="1">
<tr><td><a name="5282"></a>
 <i>checkcast_quick</i>
<td><a name="397"></a>
 

<tr><td><a name="5284"></a>
 <i>indexbyte1</i>
<td><a name="404"></a>
 

<tr><td><a name="5286"></a>
 <i>indexbyte2</i>
<td><a name="411"></a>
 

</Table><br><br><p>
<a name="checkcast_quick.Forms"></a>
<b>Forms</h3></b>
<a name="5288"></a>
<i>checkcast_quick</i> = 224 (0xe0)<p>
<a name="checkcast_quick.Stack"></a>
<b>Stack</h3></b>
<a name="12449"></a>
 ..., <i>objectref</i><em> </em><img src="chars/arrwdbrt.gif"> ..., <i>objectref</i><p>
<a name="checkcast_quick.Description"></a>
<b>Description</h3></b>
<a name="5289"></a>
The <i>objectref</i> must be of type <code>reference</code>. The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The object at that index of the constant pool must already have been successfully resolved and must be a class or interface type.<p>
<a name="18707"></a>
If <i>objectref</i> is <code>null</code> or can be cast to the resolved class, array, or interface type, the operand stack is unchanged; otherwise, the <i>checkcast_quick</i> instruction throws a <code>ClassCastException</code>.<p>
<a name="18708"></a>
The following rules are used to determine whether an <i>objectref</i> that is not <code>null</code> can be cast to the resolved type: If S is the class of the object referred to by <i>objectref</i> and T is the resolved class, array, or interface type, <i>checkcast_quick</i> determines whether <i>objectref</i> can be cast to type T as follows:<p>
<ul><a name="11836"></a>
<li>If S is an ordinary (non-array) class, then:
<ul>
<a name="11840"></a>
<li>If T is a class type, then S must be the same class <a href="Concepts.doc.html#20389">(&#167;2.8.1)</a> as T, or S must be a subclass of T;
<a name="11844"></a>
<li>If T is an interface type, then S must implement <a href="Concepts.doc.html#16432">(&#167;2.13)</a> interface T.
</ul>
</ul>
<a name="checkcast_quick"></a>
<ul><a name="11845"></a>
<li>If S is a class representing the array type SC<code>[]</code>, that is, an array of components of type SC, then:
<ul>
<a name="11849"></a>
<li>If T is a class type, then T must be <code>Object</code> <a href="Concepts.doc.html#27433">(&#167;2.4.6)</a>.
<a name="11850"></a>
<li>If T is an array type TC<code>[]</code>, that is, an array of components of type TC, then one of the following must be true:
<ul>
<a name="11854"></a>
<li>TC and SC are the same primitive type <a href="Concepts.doc.html#19511">(&#167;2.4.1)</a>.
<a name="11858"></a>
<li>TC and SC are reference types <a href="Concepts.doc.html#25376">(&#167;2.4.5)</a> and type SC can be cast to TC by these runtime rules. 
</ul>
</ul>
</ul><a name="8098"></a>
S cannot be an interface type, because there are no instances of interfaces, only instances of classes and arrays.<p>
<a name="checkcast_quick.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="12063"></a>
If <i>objectref</i><em> </em>cannot be cast to the type of the resolved class, the <i>checkcast_quick</i> instruction throws a <code>ClassCastException</code>.<p>
<a name="checkcast_quick.Notes"></a>
<b>Notes</h3></b>
<a name="5295"></a>
The opcode of this instruction was originally <i>checkcast</i>. The operands of the <i>checkcast</i> instruction are not modified.<p>
<a name="8217"></a>
The <i>checkcast_quick</i> instruction is very similar to the <i>instanceof_quick</i> instruction. It differs in its treatment of <code>null</code>, its behavior when its test fails (<i>checkcast_quick</i> throws an exception, <i>instanceof_quick</i> pushes a result code), and its effect on the operand stack.<p>

<a name="getfield_quick"></a>
<hr><h2>getfield_quick</h2>
<a name="getfield_quick.Operation"></a>
<b>Operation</h3></b>
<a name="5081"></a>
Fetch field from object<p><Table Border="1">
<tr><td><a name="5076"></a>
 <i>getfield_quick</i>
<td><a name="222"></a>
 

<tr><td><a name="5078"></a>
 <i>offset</i>
<td><a name="229"></a>
 

<tr><td><a name="5080"></a>
 <i>&lt;unused&gt;</i>
<td><a name="236"></a>
 

</Table><br><br><p>
<a name="getfield_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12450"></a>
<i>getfield_quick</i> = 206 (0xce)<p>
<a name="getfield_quick.Stack"></a>
<b>Stack</h3></b>
<a name="5082"></a>
..., <i>objectref</i><em> </em><img src="chars/arrwdbrt.gif">  ..., <i>value</i> <p>
<a name="getfield_quick.Description"></a>
<b>Description</h3></b>
<a name="5083"></a>
The <i>objectref</i>, which must be of type <code>reference</code>, is popped from the operand stack. The <i>value</i> of the one-word field at <i>offset</i> into the class instance referenced by <i>objectref</i> is fetched and pushed onto the operand stack.<p>
<a name="getfield_quick.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="12066"></a>
If <i>objectref</i> is <code>null</code>, the <i>getfield_quick</i> instruction throws a <code>NullPointerException</code>.<p>
<a name="getfield_quick.Notes"></a>
<b>Notes</h3></b>
<a name="6425"></a>
The opcode of this instruction was originally <i>getfield</i>, operating on a field determined dynamically to have an offset into the class instance data of 255 words or less and to have a width of one word. <p>
<a name="17428"></a>
When the constant pool entry referenced by a <i>getfield</i> instruction is resolved, the offset for the field it references is generated. That offset replaces the first operand byte of the original <i>getfield</i> instruction. The second operand byte of the <i>getfield</i> is unused by <i>getfield_quick</i>. <p>

<a name="getfield_quick_w"></a>
<hr><h2>getfield_quick_w</h2>
<a name="getfield_quick_w.Operation"></a>
<b>Operation</h3></b>
<a name="6628"></a>
Fetch field from object<p><Table Border="1">
<tr><td><a name="6623"></a>
 <i>getfield_quick_w</i>
<td><a name="553"></a>
 

<tr><td><a name="6625"></a>
 <i>indexbyte1</i>
<td><a name="560"></a>
 

<tr><td><a name="6627"></a>
 <i>indexbyte2</i>
<td><a name="567"></a>
 

</Table><br><br><p>
<a name="getfield_quick_w.Forms"></a>
<b>Forms</h3></b>
<a name="12451"></a>
<i>getfield_quick_w</i> = 227 (0xe3)<p>
<a name="getfield_quick_w.Stack"></a>
<b>Stack</h3></b>
<a name="6629"></a>
 ..., <i>objectref</i><em> </em><img src="chars/arrwdbrt.gif">  ..., <i>value</i> <p>
<a name="17034"></a>
OR<p>
<a name="getfield_quick_w.Stack"></a>
<b>Stack</h3></b>
<a name="14768"></a>
 ..., <i>objectref</i><em> </em><img src="chars/arrwdbrt.gif"> ..., <i>value.word1</i>, <i>value.word2</i><p>
<a name="getfield_quick_w.Description"></a>
<b>Description</h3></b>
<a name="6630"></a>
The <i>objectref</i>, which must be of type <code>reference</code>, is popped from the operand stack. The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The constant pool item at the index must be a <code>CONSTANT_Fieldref</code> <a href="ClassFile.doc.html#4723">(&#167;4.4.2)</a> which must already have been resolved and must not be a class (<code>static</code>) field. A field offset must have been stored in the constant pool. The <i>value</i> at that offset into the class instance referenced by <i>objectref</i> is fetched and pushed onto the operand stack.<p>
<a name="getfield_quick_w.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="12069"></a>
If <i>objectref</i> is <code>null</code>, the <i>getfield_quick_w</i> instruction throws a <code>NullPointerException</code>.<p>
<a name="getfield_quick_w.Notes"></a>
<b>Notes</h3></b>
<a name="6632"></a>
The opcode of this instruction was originally <i>getfield</i>, operating on a field determined dynamically to have an offset into the class instance data of more than 255 words. <p>

<a name="getfield_quick_w"></a>
<a name="17427"></a>
The operands of the <i>getfield</i> instruction are not modified. Because the <i>getfield_quick_w</i> instruction operates on both one- and two-word wide fields, it needs to know both the field offset and the type of that field. Because the original <i>getfield</i> instruction needed a 16-bit index, the field offset may be 16 bits wide. As there is insufficient space in the instruction to store both a 16-bit offset and a field type, <i>getfield_quick_w</i> retains its original operands and uses them to index into the constant pool, where the offset and field type are available in the resolved entry.<p>

<a name="getfield2_quick"></a>
<hr><h2>getfield2_quick</h2>
<a name="getfield2_quick.Operation"></a>
<b>Operation</h3></b>
<a name="5099"></a>
Fetch <code>long</code> or <code>double</code> field from object<p><Table Border="1">
<tr><td><a name="5094"></a>
 <i>getfield2_quick</i>
<td><a name="475"></a>
 

<tr><td><a name="5096"></a>
 <i>offset</i>
<td><a name="482"></a>
 

<tr><td><a name="5098"></a>
 <i>&lt;unused&gt;</i>
<td><a name="489"></a>
 

</Table><br><br><p>
<a name="getfield2_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12452"></a>
<i>getfield2_quick</i> = 208 (0xd0)<p>
<a name="getfield2_quick.Stack"></a>
<b>Stack</h3></b>
<a name="8389"></a>
 ..., <i>objectref</i> <img src="chars/arrwdbrt.gif">  ..., <i>value.word1</i>, <i>value.word2</i><p>
<a name="getfield2_quick.Description"></a>
<b>Description</h3></b>
<a name="8391"></a>
The <i>objectref</i>, which must be of type <code>reference</code>, is popped from the operand stack. The <i>value</i> of the two-word field at <i>offset</i> into the class instance referenced by <i>objectref</i> is fetched and pushed onto the operand stack.<p>
<a name="getfield2_quick.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="12072"></a>
If <i>objectref</i> is <code>null</code>, the <i>getfield2_quick</i> instruction throws a <code>NullPointerException</code>.<p>
<a name="getfield2_quick.Notes"></a>
<b>Notes</h3></b>
<a name="8918"></a>
The opcode of this instruction was originally <i>getfield</i>, operating on a field determined dynamically to have an offset into the class instance data of 255 words or less and to have a width of two words. <p>
<a name="17426"></a>
When the constant pool entry referenced by a <i>getfield</i> instruction is resolved, the offset for the field it references is generated. That offset replaces the first operand of the original <i>getfield</i> instruction. The second operand of the <i>getfield</i> is unused by <i>getfield2_quick</i>. <p>

<a name="getstatic_quick"></a>
<hr><h2>getstatic_quick</h2>
<a name="getstatic_quick.Operation"></a>
<b>Operation</h3></b>
<a name="8932"></a>
Get static field from class<p><Table Border="1">
<tr><td><a name="8927"></a>
 <i>getstatic_quick</i>
<td><a name="300"></a>
 

<tr><td><a name="8929"></a>
 <i>indexbyte1</i>
<td><a name="307"></a>
 

<tr><td><a name="8931"></a>
 <i>indexbyte2</i>
<td><a name="314"></a>
 

</Table><br><br><p>
<a name="getstatic_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12453"></a>
<i>getstatic_quick</i> = 210 (0xd2)<p>
<a name="getstatic_quick.Stack"></a>
<b>Stack</h3></b>
<a name="5122"></a>
 ..., <img src="chars/arrwdbrt.gif">  ..., <i>value</i> <p>
<a name="getstatic_quick.Description"></a>
<b>Description</h3></b>
<a name="5123"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The constant pool item at that index must be a <code>CONSTANT_Fieldref</code> <a href="ClassFile.doc.html#4723">(&#167;4.4.2)</a> which must already have been resolved and must be a class (<code>static</code>) field that is one word wide. The <i>value</i> of that class field is fetched and pushed onto the operand stack.<p>
<a name="getstatic_quick.Notes"></a>
<b>Notes</h3></b>
<a name="5127"></a>
The opcode of this instruction was originally <i>getstatic</i>, operating on a <code>static</code> field determined dynamically to be one word wide. The operands of the <i>getstatic</i> instruction are not modified. There is no equivalent to the <i>getfield_quick</i> instruction, storing a class offset as an instruction operand, for one-word <code>static</code> fields.<p>

<a name="getstatic2_quick"></a>
<hr><h2>getstatic2_quick</h2>
<a name="getstatic2_quick.Operation"></a>
<b>Operation</h3></b>
<a name="5141"></a>
Get static field from class<p><Table Border="1">
<tr><td><a name="5136"></a>
 <i>getstatic2_quick</i>
<td><a name="527"></a>
 

<tr><td><a name="5138"></a>
 <i>indexbyte1</i>
<td><a name="534"></a>
 

<tr><td><a name="5140"></a>
 <i>indexbyte2</i>
<td><a name="541"></a>
 

</Table><br><br><p>
<a name="getstatic2_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12454"></a>
<i>getstatic2_quick</i> = 212 (0xd4)<p>
<a name="getstatic2_quick.Stack"></a>
<b>Stack</h3></b>
<a name="5142"></a>
 ...,<em> </em><img src="chars/arrwdbrt.gif">  ..., <i>value.word1</i>, <i>value.word2</i><p>
<a name="getstatic2_quick.Description"></a>
<b>Description</h3></b>
<a name="5143"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The constant pool item at that index must be a <code>CONSTANT_Fieldref</code> <a href="ClassFile.doc.html#4723">(&#167;4.4.2)</a> which must already have been resolved and must be a class (<code>static</code>) field that is two words wide. The <i>value</i> of that class field is fetched and pushed onto the operand stack.<p>
<a name="8437"></a>
The constant pool item is a field reference to a static field of a class. The type of the field must be <code>long</code> or <code>double</code>. The value of that field is pushed onto the stack.<p>
<a name="getstatic2_quick.Notes"></a>
<b>Notes</h3></b>
<a name="8485"></a>
The opcode of this instruction was originally <i>getstatic</i>, operating on a class field determined dynamically to be two words wide. The operands of the <i>getstatic</i> instruction are not modified. There is no equivalent to the <i>getfield2_quick</i> instruction, storing a class offset as an instruction operand, for two-word <code>static</code> fields.<p>

<a name="instanceof_quick"></a>
<hr><h2>instanceof_quick</h2>
<a name="instanceof_quick.Operation"></a>
<b>Operation</h3></b>
<a name="5311"></a>
<p><Table Border="1">
<tr><td><a name="5306"></a>
 <i>instanceof_quick</i>
<td><a name="423"></a>
 

<tr><td><a name="5308"></a>
 <i>indexbyte1</i>
<td><a name="430"></a>
 

<tr><td><a name="5310"></a>
 <i>indexbyte2</i>
<td><a name="437"></a>
 

</Table><br><br>Determine if object is of given type<p>
<a name="instanceof_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12455"></a>
<i>instanceof_quick</i> = 225 (0xe1)<p>
<a name="instanceof_quick.Stack"></a>
<b>Stack</h3></b>
<a name="5312"></a>
 ..., <i>objectref</i><em> </em><img src="chars/arrwdbrt.gif">  ..., <i>result</i><p>
<a name="instanceof_quick.Description"></a>
<b>Description</h3></b>
<a name="8113"></a>
The <i>objectref</i>, which must be of type <code>reference</code>, is popped from the operand stack. The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The class at that index of the constant pool must have already been successfully resolved and may be a class, array, or interface.<p>
<a name="18712"></a>
If <i>objectref</i> is not <code>null</code> and is an instance of the resolved class, array, or interface, the <i>instanceof_quick</i> instruction pushes an <code>int</code> <i>result</i> of <i>1</i> as an int on the operand stack. Otherwise, it pushes an <code>int</code> <i>result</i> of <i>0</i>.<p>
<a name="18713"></a>
The following rules are used to determine whether an <i>objectref</i> that is not <code>null</code> is an instance of the resolved type: If S is the class of the object referred to by <i>objectref</i> and T is the resolved class, array, or instance type, <i>instanceof_quick</i> determines whether <i>objectref</i> is an instance of T as follows:<p>
<ul><a name="11862"></a>
<li>If S is an ordinary (non-array) class, then:
<ul>
<a name="11866"></a>
<li>If T is a class type, then S must be the same class <a href="Concepts.doc.html#20389">(&#167;2.8.1)</a> as T, or a subclass of T.
<a name="11870"></a>
<li>If T is an interface type, then S must implement <a href="Concepts.doc.html#16432">(&#167;2.13)</a> interface T.
</ul>
</ul>
<a name="instanceof_quick"></a>
<hr><h2>instanceof_quick</h2>
<ul><a name="11871"></a>
<li>If S is a class representing the array type SC<code>[]</code>, that is, an array of components of type SC, then:
<ul>
<a name="11875"></a>
<li>If T is a class type, then T must be <code>Object</code> <a href="Concepts.doc.html#27433">(&#167;2.4.6)</a>.
<a name="11876"></a>
<li>If T is an array type TC<code>[]</code>, that is, an array of components of type TC, then one of the following must be true:
<ul>
<a name="11880"></a>
<li>TC and SC are the same primitive type <a href="Concepts.doc.html#19511">(&#167;2.4.1)</a>.
<a name="11884"></a>
<li>TC and SC are reference types <a href="Concepts.doc.html#25376">(&#167;2.4.5)</a> and type SC can be cast to TC by these runtime rules. 
</ul>
</ul>
</ul><a name="8134"></a>
S cannot be an interface type, because there are no instances of interfaces, only instances of classes and arrays.<p>
<a name="instanceof_quick.Notes"></a>
<b>Notes</h3></b>
<a name="5318"></a>
The opcode of this instruction was originally <i>instanceof</i>. The operands of the <i>instanceof</i> instruction are not modified.<p>

<a name="invokeinterface_quick"></a>
<hr><h2>invokeinterface_quick</h2>
<a name="invokeinterface_quick.Operation"></a>
<b>Operation</h3></b>
<a name="5257"></a>
Invoke interface method<p><Table Border="1">
<tr><td><a name="5248"></a>
 <i>invokeinterface_quick</i>
<td><a name="182"></a>
 

<tr><td><a name="5250"></a>
 <i>idbyte1</i>
<td><a name="189"></a>
 

<tr><td><a name="5252"></a>
 <i>idbyte2</i>
<td><a name="196"></a>
 

<tr><td><a name="5254"></a>
 <i>nargs</i>
<td><a name="203"></a>
 

<tr><td><a name="5256"></a>
 <i>guess</i>
<td><a name="210"></a>
 

</Table><br><br><p>
<a name="invokeinterface_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12456"></a>
<i>invokeinterface_quick</i> = 218 (0xda)<p>
<a name="invokeinterface_quick.Stack"></a>
<b>Stack</h3></b>
<a name="5258"></a>
 ...<em>, </em><i>objectref</i><em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif"> ...<p>
<a name="invokeinterface_quick.Description"></a>
<b>Description</h3></b>
<a name="11638"></a>
The unsigned <i>idbyte1</i> and <i>idbyte2</i> are used to construct an identifier for the name and descriptor <a href="ClassFile.doc.html#7035">(&#167;4.3.3)</a> of the desired method, where the value of the identifier is (<i>idbyte1</i> << 8) | <i>idbyte2</i>. <p>
<a name="11642"></a>
The <i>nargs</i> operand is an unsigned byte which must not be zero. The <i>objectref</i> must be of type <code>reference</code> and must be followed on the operands stack by <i>nargs</i> - 1 words of arguments. The method table of the class of the type of <i>objectref</i> is determined. If <i>objectref</i> is an array type, then the method table of class <code>Object</code> is used.<p>
<a name="11615"></a>
The unsigned <i>guess</i> is used to index into the method table. If there is a method at index <i>guess</i>, and if its identifier is identical to the constructed identifier, then that method is selected. Otherwise, the method table is searched for a method whose identifier is identical to the constructed identifier. If one is found, the current value of <i>guess</i> is overwritten by that index.<p>
<a name="11655"></a>
The result of the search is a method table entry, which includes a direct reference to the code for the interface method and the method's modifier information ((see <a href="ClassFile.doc.html#12725">Table 4.4, "Method access and modifier flags"</a>). The method table entry must be that of a <code>public</code> method.<p>

<a name="invokeinterface_quick"></a>
<hr><h2>invokeinterface_quick</h2>
<a name="18526"></a>
If the method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is acquired.<p>
<a name="18527"></a>
If the method is not <code>native</code>, the <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack. A new stack frame is created for the method being invoked, and <i>objectref</i> and the words of arguments are made the values of its first <i>nargs</i> local variables, with <i>objectref</i> in local variable <i>0</i>, <i>arg1</i> in local variable <i>1</i>, and so on. The new stack frame is then made current, and the Java Virtual Machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<p>
<a name="18528"></a>
If the method is <code>native</code> and the platform-dependent code that implements it has not yet been loaded and linked into the Java Virtual Machine, that is done. The <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack; the code that implements the method is invoked in an implementation-dependent manner.<p>
<a name="invokeinterface_quick.Linking"></a>
<b>Linking Exceptions</h3></b>
<a name="12075"></a>
If no method matching the resolved name and descriptor can be found in the class of <i>objectref</i>, <i>invokeinterface_quick</i> throws an <code>IncompatibleClassChangeError</code>.<p>
<a name="11782"></a>
 Otherwise, if the selected method is a class (<code>static</code>) method, the <i>invokeinterface_quick</i> instruction throws an <code>IncompatibleClassChangeError</code>.<p>
<a name="11783"></a>
 Otherwise, if the selected method is not <code>public</code>, the <i>in-vokeinterface_quick</i> instruction throws an <code>IllegalAccess-Error</code>.<p>
<a name="12163"></a>
 Otherwise, if the selected method is <code>abstract</code>, <i>invoke-interface_quick</i> throws an <code>AbstractMethodError</code>.<p>
<a name="12164"></a>
 Otherwise, if the selected method is <code>native</code> and the code that implements the method cannot be loaded or linked, <i>invoke-interface_quick </i>throws an <code>UnsatisfiedLinkError</code>.<p>

<a name="invokeinterface_quick"></a>
<hr><h2>invokeinterface_quick</h2>
<a name="invokeinterface_quick.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="5268"></a>
Otherwise, if <i>objectref</i> is <code>null</code>, the <i>invokeinterface_quick</i> instruction throws a <code>NullPointerException</code>. <p>
<a name="invokeinterface_quick.Notes"></a>
<b>Notes</h3></b>
<a name="5270"></a>
The opcode of this instruction was originally <i>invokeinterface</i>. The initial value of <i>guess</i> is 0, the operand value supplied by <i>invokeinterface</i>. The identifiers being compared and stored in the <i>invokeinterface_quick</i> instruction encode a method name and descriptor as a 16-bit quantity that can be compared quickly. The details of the encoding are implementation-specific. The bytes of the identifier for the method being invoked, <i>idbyte1</i> and <i>idbyte2</i>, replace the original constant pool index bytes. The identifier can be calculated when each method is loaded, or at run time. The value of the <i>nargs</i> operand is not modified.<p>

<a name="invokenonvirtual_quick"></a>
<hr><h2>invokenonvirtual_quick</h2>
<a name="invokenonvirtual_quick.Operation"></a>
<b>Operation</h3></b>
<a name="12217"></a>
Invoke an instance initialization method or a private method, dispatching based on compile-time type<p><Table Border="1">
<tr><td><a name="12212"></a>
 <i>invokenonvirtual_quick</i>
<td><a name="664"></a>
 

<tr><td><a name="12214"></a>
 <i>indexbyte1</i>
<td><a name="671"></a>
 

<tr><td><a name="12216"></a>
 <i>indexbyte2</i>
<td><a name="678"></a>
 

</Table><br><br><p>
<a name="invokenonvirtual_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12457"></a>
<i>invokenonvirtual_quick</i> = 215 (0xd7)<p>
<a name="invokenonvirtual_quick.Stack"></a>
<b>Stack</h3></b>
<a name="12218"></a>
 ...<em>, </em><i>objectref</i><em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif">  ...<p>
<a name="invokenonvirtual_quick.Description"></a>
<b>Description</h3></b>
<a name="12219"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The constant pool item at the index must be a <code>CONSTANT_Methodref</code> <a href="ClassFile.doc.html#4723">(&#167;4.4.2)</a> which must already have been resolved successfully. The constant pool entry representing the resolved method includes a direct reference to the code for the method, an unsigned byte <i>nargs</i> which must be greater than zero, and the method's modifier information (see <a href="ClassFile.doc.html#12725">Table 4.4, "Method access and modifier flags"</a>).<p>
<a name="18530"></a>
If the method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is acquired.<p>
<a name="18531"></a>
If the method is not <code>native</code>, the <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack. A new stack frame is created for the method being invoked, and <i>objectref</i> and the words of arguments are made the values of its first <i>nargs</i> local variables, with <i>objectref</i> in local variable <i>0</i>, <i>arg1</i> in local variable <i>1</i>, and so on. The new stack frame is then made current, and the Java Virtual Machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<p>
<a name="18532"></a>
If the method is <code>native</code>, the <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack; the code that implements the method is invoked in an implementation-dependent manner.<p>
<a name="invokenonvirtual_quick.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="12339"></a>
If <i>objectref</i> is <code>null</code>, the <i>invokenonvirtual_quick</i> instruction throws a <code>NullPointerException</code>.<p>
<a name="invokenonvirtual_quick.Notes"></a>
<b>Notes</h3></b>
<a name="12233"></a>
The opcode of this instruction was originally <i>invokespecial</i>, and the method it invoked was determined dynamically to be either an instance initialization method <code>&lt;init&gt;</code> or a <code>private</code> method. The operands of the <i>invokespecial</i> instruction are not modified.<p>
<a name="18418"></a>
The difference between the <i>invokenonvirtual_quick</i> and the <i>in-vokevirtual_quick_w</i> instructions is that <i>invokevirtual_quick_w</i> invokes a method based on the actual (runtime) type of the object. The <i>invokenonvirtual_quick</i> instruction invokes an instance initialization method or <code>private</code> method based on the compile-time type of the object.<p>

<a name="invokesuper_quick"></a>
<hr><h2>invokesuper_quick</h2>
<a name="invokesuper_quick.Operation"></a>
<b>Operation</h3></b>
<a name="5203"></a>
Invoke a superclass method, dispatching based on compile-time type<p><Table Border="1">
<tr><td><a name="5198"></a>
 <i>invokesuper_quick</i>
<td><a name="326"></a>
 

<tr><td><a name="5200"></a>
 <i>indexbyte1</i>
<td><a name="333"></a>
 

<tr><td><a name="5202"></a>
 <i>indexbyte2</i>
<td><a name="340"></a>
 

</Table><br><br><p>
<a name="invokesuper_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12458"></a>
<i>invokesuper_quick</i> = 216 (0xd8)<p>
<a name="invokesuper_quick.Stack"></a>
<b>Stack</h3></b>
<a name="5204"></a>
...<em>, </em><i>objectref</i><em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif">  ...<p>
<a name="invokesuper_quick.Description"></a>
<b>Description</h3></b>
<a name="12282"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the method table of the superclass of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The specified method table entry includes a direct reference to the code for the method, an unsigned byte <i>nargs</i> which must be greater than zero, and the method's modifier information (see <a href="ClassFile.doc.html#12725">Table 4.4, "Method access and modifier flags"</a>).<p>
<a name="18545"></a>
If the method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is acquired.<p>
<a name="18546"></a>
If the method is not <code>native</code>, the <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack. A new stack frame is created for the method being invoked, and <i>objectref</i> and the words of arguments are made the values of its first <i>nargs</i> local variables, with <i>objectref</i> in local variable <i>0</i>, <i>arg1</i> in local variable <i>1</i>, and so on. The new stack frame is then made current, and the Java Virtual Machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<p>
<a name="18547"></a>
If the method is <code>native</code>, the <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack; the code that implements the method is invoked in an implementation-dependent manner.<p>
<b>Runtime Exception</h3></b>
<a name="5211"></a>
If <i>objectref</i> is <code>null</code>, the <i>invokesuper_quick</i> instruction throws a <code>NullPointerException</code>.<p>
<a name="invokesuper_quick.Notes"></a>
<b>Notes</h3></b>
<a name="12259"></a>
The opcode of this instruction was originally <i>invokespecial</i>, and the method it invoked was determined dynamically to be a method in a superclass of the current object. The operands of the <i>invokespecial</i> instruction are not modified.<p>
<a name="11950"></a>
The difference between the <i>invokesuper_quick</i> and the <i>invokevirtual_quick_w</i> instructions is that <i>invokevirtual_quick_w</i> invokes a method based on the class of the object. The <i>invokesuper_quick</i> instruction is used to invoke methods in a superclass of the current class. <p>
<a name="11952"></a>
The <i>invokesuper_quick</i> instruction was introduced in Sun's JDK 1.0.2 release to fix a bug in earlier versions of the Java Virtual Machine. Prior to that release, the <i>invokespecial</i> instruction (then named <i>invokenonvirtual</i>) would always be converted to the <i>invokenonvirtual_quick</i> instruction.<p>
<a name="11948"></a>
<p>

<a name="invokestatic_quick"></a>
<hr><h2>invokestatic_quick</h2>
<a name="invokestatic_quick.Operation"></a>
<b>Operation</h3></b>
<a name="5230"></a>
Invoke a class (static) method<p><Table Border="1">
<tr><td><a name="5225"></a>
 <i>invokestatic_quick</i>
<td><a name="52"></a>
 

<tr><td><a name="5227"></a>
 <i>indexbyte1</i>
<td><a name="59"></a>
 

<tr><td><a name="5229"></a>
 <i>indexbyte2</i>
<td><a name="66"></a>
 

</Table><br><br><p>
<a name="invokestatic_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12459"></a>
<i>invokestatic_quick</i> = 217 (0xd9)<p>
<a name="invokestatic_quick.Stack"></a>
<b>Stack</h3></b>
<a name="5231"></a>
...<em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif">  ...<p>
<a name="invokestatic_quick.Description"></a>
<b>Description</h3></b>
<a name="11579"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The constant pool item at the index must be a <code>CONSTANT_Methodref</code> <a href="ClassFile.doc.html#4723">(&#167;4.4.2)</a> which must already have been resolved successfully.<p>
<a name="11586"></a>
The constant pool entry representing the resolved method includes a direct reference to the code for the method, an unsigned byte <i>nargs</i> which may be zero, and the method's modifier information (see <a href="ClassFile.doc.html#12725">Table 4.4, "Method access and modifier flags"</a>).<p>
<a name="18563"></a>
If the method is <code>synchronized</code>, the monitor associated with the current class is acquired.<p>
<a name="18564"></a>
If the method is not <code>native</code>, the <i>nargs </i>words of arguments are popped from the operand stack. A new stack frame is created for the method being invoked, and the words of arguments are made the values of its first <i>nargs</i> local variables, with <i>arg1</i> in local variable <i>0</i>, <i>arg2</i> in local variable <i>1</i>, and so on. The new stack frame is then made current, and the Java Virtual Machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<p>
<a name="18565"></a>
If the method is <code>native</code>, the <i>nargs </i>words of arguments are popped from the operand stack; the code that implements the method is invoked in an implementation-dependent manner.<p>
<a name="invokestatic_quick.Notes"></a>
<b>Notes</h3></b>
<a name="5239"></a>
The opcode of this instruction was originally <i>invokestatic</i>. The operands of the <i>invokestatic</i> instruction are not modified.<p>

<a name="invokevirtual_quick"></a>
<hr><h2>invokevirtual_quick</h2>
<a name="invokevirtual_quick.Operation"></a>
<b>Operation</h3></b>
<a name="5161"></a>
Invoke instance method<p><Table Border="1">
<tr><td><a name="5156"></a>
 <i>invokevirtual_quick</i>
<td><a name="156"></a>
 

<tr><td><a name="5158"></a>
 <i>index</i>
<td><a name="163"></a>
 

<tr><td><a name="5160"></a>
 <i>nargs</i>
<td><a name="170"></a>
 

</Table><br><br>; dispatch based on class<p>
<a name="invokevirtual_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12460"></a>
<i>invokevirtual_quick</i> = 214 (0xd6)<p>
<a name="invokevirtual_quick.Stack"></a>
<b>Stack</h3></b>
<a name="5162"></a>
...<em>, </em><i>objectref</i><em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif"> ...<p>
<a name="invokevirtual_quick.Description"></a>
<b>Description</h3></b>
<a name="11507"></a>
The <i>objectref</i> must be of type <code>reference</code> and must reference a class instance. The <i>index</i> operand is an unsigned byte, and the <i>nargs</i> operand is an unsigned byte, which must not be zero. The <i>index</i> is an index into the method table of the class of the type of <i>objectref</i>. The table entry at that index includes the method's code and its modifier information (see <a href="ClassFile.doc.html#12725">Table 4.4, "Method access and modifier flags"</a>).<p>
<a name="18595"></a>
If the method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is acquired.<p>
<a name="22239"></a>
If the method is not <code>native</code>, the <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack. A new stack frame is created for the method being invoked, and <i>objectref</i> and the words of arguments are made the values of its first <i>nargs</i> local variables, with <i>objectref</i> in local variable <i>0</i>, <i>arg1</i> in local variable <i>1</i>, and so on. The new stack frame is then made current, and the Java Virtual Machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<p>

<a name="invokevirtual_quick"></a>
<a name="22241"></a>
If the method is <code>native</code> and the platform-dependent code that implements it has not yet been loaded and linked into the Java Virtual Machine, that is done. The <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack; the code that implements the method is invoked in an implementation-dependent manner.<p>
<a name="invokevirtual_quick.Linking"></a>
<b>Linking Exception</h3></b>
<a name="12125"></a>
If the specified method is <code>native</code> and the code that implements the method cannot be loaded or linked, the <i>invokevirtual_quick</i> instruction throws an <code>UnsatisfiedLinkError</code>.<p>
<a name="invokevirtual_quick.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="5166"></a>
Otherwise, if <i>objectref</i> is <code>null</code>, the <i>invokevirtual_quick</i> instruction throws a <code>NullPointerException</code>. <p>
<a name="invokevirtual_quick.Notes"></a>
<b>Notes</h3></b>
<a name="5168"></a>
The opcode of this instruction was originally <i>invokevirtual</i>, with <i>objectref</i> not referring to an instance of <code>java.lang.Object</code> and with operands determined dynamically to represent a method with a method table index of 255 or less. When the constant pool entry referenced by an <i>invokevirtual</i> instruction is resolved, a one-byte index for the method it references is generated. That index replaces the first operand byte of the original <i>invokevirtual</i> instruction. The second operand byte of the <i>invokevirtual</i> instruction is replaced by <i>nargs</i>, the number of argument words expected by the method.<p>
<a name="12640"></a>
An <i>invokevirtual</i> instruction referring to an instance of <code>java.lang.Object</code> and with operands representing a constant pool index of 255 or less will instead be converted into an <i>invokevirtualobject_quick</i> instruction. Any <i>invokevirtual</i> instruction with operands representing a constant pool index greater than 255 will be converted into an <i>invokevirtual_quick_w</i> instruction.<p>

<a name="invokevirtual_quick_w"></a>
<hr><h2>invokevirtual_quick_w</h2>
<a name="invokevirtual_quick_w.Operation"></a>
<b>Operation</h3></b>
<a name="6740"></a>
Invoke instance method<p><Table Border="1">
<tr><td><a name="6735"></a>
 <i>invokevirtual_quick_w</i>
<td><a name="638"></a>
 

<tr><td><a name="6737"></a>
 <i>indexbyte1</i>
<td><a name="645"></a>
 

<tr><td><a name="6739"></a>
 <i>indexbyte2</i>
<td><a name="652"></a>
 

</Table><br><br>, dispatching on class (wide index)<p>
<a name="invokevirtual_quick_w.Forms"></a>
<b>Forms</h3></b>
<a name="12461"></a>
<i>invokevirtual_quick_w</i> = 226 (0xe2)<p>
<a name="invokevirtual_quick_w.Stack"></a>
<b>Stack</h3></b>
<a name="6741"></a>
...<em>, </em><i>objectref</i><em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif"> ...<p>
<a name="invokevirtual_quick_w.Description"></a>
<b>Description</h3></b>
<a name="8709"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The constant pool item at the index must be a <code>CONSTANT_Methodref</code> <a href="ClassFile.doc.html#4723">(&#167;4.4.2)</a> which must already have been resolved successfully. The constant pool entry representing the resolved method includes an unsigned <i>index</i> into the method table of the resolved class and an unsigned byte <i>nargs</i> which must not be zero.<p>
<a name="11542"></a>
The <i>objectref</i> must be of type <code>reference</code>. The <i>index</i> is used as an index into the method table of the class of the type of <i>objectref</i>. If the <i>objectref</i> is an array type, then the method table of class <code>Object</code> is used. The table entry at that index includes the method's code and its modifier information (see <a href="ClassFile.doc.html#12725">Table 4.4, "Method access and modifier flags"</a>).<p>
<a name="18603"></a>
If the method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is acquired.<p>

<a name="invokevirtual_quick_w"></a>
<a name="18604"></a>
If the method is not <code>native</code>, the <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack. A new stack frame is created for the method being invoked, and <i>objectref</i> and the words of arguments are made the values of its first <i>nargs</i> local variables, with <i>objectref</i> in local variable <i>0</i>, <i>arg1</i> in local variable <i>1</i>, and so on. The new stack frame is then made current, and the Java Virtual Machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<p>
<a name="18605"></a>
If the method is <code>native</code> and the platform-dependent code that implements it has not yet been loaded and linked into the Java Virtual Machine, that is done. The <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack; the code that implements the method is invoked in an implementation-dependent manner.<p>
<a name="invokevirtual_quick_w.Linking"></a>
<b>Linking Exception</h3></b>
<a name="12154"></a>
If the specified method is <code>native</code> and the code that implements the method cannot be loaded or linked, the <i>invokevirtual_quick_w</i> instruction throws an <code>UnsatisfiedLinkError</code>.<p>
<a name="invokevirtual_quick_w.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="6745"></a>
Otherwise, if <i>objectref</i> is <code>null</code>, the <i>invokevirtual_quick_w</i> instruction throws a <code>NullPointerException</code>. <p>
<a name="invokevirtual_quick_w.Notes"></a>
<b>Notes</h3></b>
<a name="6747"></a>
The opcode of this instruction was originally <i>invokevirtual</i>, with operands determined dynamically to represent a method with a method table index greater than 255. The operands of the <i>invokevirtual</i> instruction are not modified.<p>
<a name="9000"></a>
The <i>invokevirtual_quick</i> and <i>invokevirtualobject_quick</i> instructions only support a one-byte offset into the method table of <i>objectref</i>. The <i>invokevirtual_quick_w</i> instruction can be used to for invocations of methods that cannot be represented using <i>invokevirtual_quick</i>.<p>

<a name="invokevirtualobject_quick"></a>
<hr><h2>invokevirtualobject_quick</h2>
<a name="invokevirtualobject_quick.Operation"></a>
<b>Operation</h3></b>
<a name="9288"></a>
Invoke instance method<p><Table Border="1">
<tr><td><a name="9283"></a>
 <i>invokevirtualobject_quick</i>
<td><a name="78"></a>
 

<tr><td><a name="9285"></a>
 <i>index</i>
<td><a name="85"></a>
 

<tr><td><a name="9287"></a>
 <i>nargs</i>
<td><a name="92"></a>
 

</Table><br><br> of class <code>java.lang.Object</code><p>
<a name="invokevirtualobject_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12462"></a>
<i>invokevirtualobject_quick</i> = 219 (0xdb)<p>
<a name="invokevirtualobject_quick.Stack"></a>
<b>Stack</h3></b>
<a name="9289"></a>
...<em>, </em><i>objectref</i><em>, [</em><i>arg1</i><em>, [</em><i>arg2</i><em> </em>...<em>]] </em><img src="chars/arrwdbrt.gif"> ...<p>
<a name="invokevirtualobject_quick.Description"></a>
<b>Description</h3></b>
<a name="9068"></a>
The <i>objectref</i> must be of type <code>reference</code>. The <i>index</i> operand is an unsigned byte, and the <i>nargs</i> operand is an unsigned byte which must not be zero. The <i>index</i> is an index into the method table of the class of the type of <i>objectref</i>. If the <i>objectref</i> is an array type, then the method table of class <code>Object</code> is used. The table entry at that index includes the method's code and its modifier information (see <a href="ClassFile.doc.html#12725">Table 4.4, "Method access and modifier flags"</a>).<p>
<a name="18607"></a>
If the method is <code>synchronized</code>, the monitor associated with <i>objectref</i> is acquired.<p>
<a name="22862"></a>
If the method is not <code>native</code>, the <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack. A new stack frame is created for the method being invoked, and <i>objectref</i> and the words of arguments are made the values of its first <i>nargs</i> local variables, with <i>objectref</i> in local variable <i>0</i>, <i>arg1</i> in local variable <i>1</i>, and so on. The new stack frame is then made current, and the Java Virtual Machine <code>pc</code> is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.<p>

<a name="invokevirtualobject_quick"></a>
<a name="22864"></a>
If the method is <code>native</code> and the platform-dependent code that implements it has not yet been loaded and linked into the Java Virtual Machine, that is done. The <i>nargs </i>- 1 words of arguments and <i>objectref</i> are popped from the operand stack; the code that implements the method is invoked in an implementation-dependent manner.<p>
<a name="invokevirtualobject_quick.Linking"></a>
<b>Linking Exception</h3></b>
<a name="12194"></a>
If the specified method is <code>native</code> and the code that implements the method cannot be loaded or linked, <i>invokevirtual_quick</i> throws an <code>UnsatisfiedLinkError</code>.<p>
<a name="invokevirtualobject_quick.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="12078"></a>
Otherwise, if <i>objectref</i> is <code>null</code>, the <i>invokevirtualobject_quick</i> instruction throws a <code>NullPointerException</code>.<p>
<a name="invokevirtualobject_quick.Notes"></a>
<b>Notes</h3></b>
<a name="9302"></a>
The opcode of this instruction was originally <i>invokevirtual</i>, and it referred to a method of the class <code>java.lang.Object</code> determined dynamically to have a method table index of 255 or less. The <i>invokevirtualobject_quick</i> instruction is specifically for the benefit of arrays.<p>
<a name="5908"></a>
When the constant pool entry referenced by an <i>invokevirtual</i> instruction is resolved, a one-byte index for the method it references is generated. That index replaces the first operand byte of the original <i>invokevirtual</i> instruction. The second operand byte of the <i>invokevirtual</i> instruction is replaced by <i>nargs</i>, the number of argument words expected by the method.<p>
<a name="28017"></a>
The <i>invokevirtualobject_quick</i> instruction only supports a one-byte index into the method table of <i>objectref</i>. Objects with large numbers of methods may not be able to have all their methods referenced with <i>_quick</i> variants. It is always correct, if less efficient, to re-fuse to convert an instance of an <i>invokevirtual</i> instruction to <i>invokevirtualobject_quick</i>.<p>
<a name="12643"></a>
An <i>invokevirtual</i> instruction not referring to an instance of <code>java.lang.Object</code> and with operands representing a constant pool index of 255 or less will instead be converted into an <i>invokevirtual_quick</i> instruction. Any <i>invokevirtual</i> instruction with operands representing a constant pool index greater than 255 will be converted into an <i>invokevirtual_quick_w</i> instruction.<p>

<a name="ldc_quick"></a>
<hr><h2>ldc_quick</h2>
<a name="ldc_quick.Operation"></a>
<b>Operation</h3></b>
<a name="3824"></a>
Push item from constant pool<p><Table Border="1">
<tr><td><a name="3821"></a>
 <i>ldc_quick</i>
<td><a name="352"></a>
 

<tr><td><a name="3823"></a>
 <i>index</i>
<td><a name="359"></a>
 

</Table><br><br><p>
<a name="ldc_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12463"></a>
<i>ldc_quick</i> = 203 (0xcb)<p>
<a name="ldc_quick.Stack"></a>
<b>Stack</h3></b>
<a name="5577"></a>
... <img src="chars/arrwdbrt.gif">  ..., <i>item</i><p>
<a name="ldc_quick.Description"></a>
<b>Description</h3></b>
<a name="5578"></a>
The <i>index</i> is an unsigned byte that must be a valid index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The constant pool <i>item</i> at <i>index</i> must have already been resolved and must be one word wide. The <i>item</i> is fetched from the constant pool and pushed onto the operand stack.<p>
<a name="ldc_quick.Notes"></a>
<b>Notes</h3></b>
<a name="4235"></a>
The opcode of this instruction was originally <i>ldc</i>. The operand of the <i>ldc</i> instruction is not modified.<p>

<a name="ldc_w_quick"></a>
<hr><h2>ldc_w_quick</h2>
<a name="ldc_w_quick.Operation"></a>
<b>Operation</h3></b>
<a name="9443"></a>
Push item from constant pool<p><Table Border="1">
<tr><td><a name="9438"></a>
 <i>ldc_w_quick</i>
<td><a name="104"></a>
 

<tr><td><a name="9440"></a>
 <i>indexbyte1</i>
<td><a name="111"></a>
 

<tr><td><a name="9442"></a>
 <i>indexbyte2</i>
<td><a name="118"></a>
 

</Table><br><br> (wide index)<p>
<a name="ldc_w_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12464"></a>
<i>ldc_w_quick</i> = 204 (0xcc)<p>
<a name="ldc_w_quick.Stack"></a>
<b>Stack</h3></b>
<a name="9444"></a>
... <img src="chars/arrwdbrt.gif">  ..., <i>item</i><p>
<a name="ldc_w_quick.Description"></a>
<b>Description</h3></b>
<a name="9445"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are assembled into an unsigned 16-bit index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The index must be a valid index into the constant pool of the current class. The constant pool <i>item</i> at the index must have already been resolved and must be one word wide. The <i>item</i> is fetched from the constant pool and pushed onto the operand stack.<p>
<a name="ldc_w_quick.Notes"></a>
<b>Notes</h3></b>
<a name="4243"></a>
The opcode of this instruction was originally <i>ldc_w</i>. The operands of the <i>ldc_w</i> instruction are not modified.<p>
<a name="4193"></a>
The <i>ldc_w_quick</i> instruction is identical to the <i>ldc_quick</i> instruction, except for its wider constant pool index.<p>

<a name="ldc2_w_quick"></a>
<hr><h2>ldc2_w_quick</h2>
<a name="ldc2_w_quick.Operation"></a>
<b>Operation</h3></b>
<a name="6685"></a>
Push <code>long</code> or <code>double</code> from constant pool (wide index)<p><Table Border="1">
<tr><td><a name="6680"></a>
 <i>ldc2_w_quick</i>
<td><a name="130"></a>
 

<tr><td><a name="6682"></a>
 <i>indexbyte1</i>
<td><a name="137"></a>
 

<tr><td><a name="6684"></a>
 <i>indexbyte2</i>
<td><a name="144"></a>
 

</Table><br><br><p>
<a name="ldc2_w_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12465"></a>
<i>ldc2_w_quick</i> = 205 (0xcd)<p>
<a name="ldc2_w_quick.Stack"></a>
<b>Stack</h3></b>
<a name="6686"></a>
... <img src="chars/arrwdbrt.gif"> ...,<em> </em><i>item.word1</i>, <i>item.word2</i><p>
<a name="ldc2_w_quick.Description"></a>
<b>Description</h3></b>
<a name="6687"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are assembled into an unsigned 16-bit index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The index must be a valid index into the constant pool of the current class. The (64-bit) constant pool <i>constant</i> at the index must have already been resolved and must be two words wide.<p>
<a name="ldc2_w_quick.Notes"></a>
<b>Notes</h3></b>
<a name="4187"></a>
The opcode of this instruction was originally <i>ldc2_w</i>. The operands of the original <i>ldc2_w</i> instruction are not modified.<p>
<a name="4260"></a>
Only a wide index version of this instruction exists; there is no <i>ldc2_quick</i> instruction that pushes a two-word constant with a single-byte index.<p>
<a name="4184"></a>
<p>
<a name="9076"></a>
<p>

<a name="multianewarray_quick"></a>
<hr><h2>multianewarray_quick</h2>
<a name="multianewarray_quick.Operation"></a>
<b>Operation</h3></b>
<a name="852"></a>
Create new multidimensional array<p><Table Border="1">
<tr><td><a name="845"></a>
 <i>multianewarray_quick</i>
<td><a name="579"></a>
 

<tr><td><a name="847"></a>
 <i>indexbyte1</i>
<td><a name="586"></a>
 

<tr><td><a name="849"></a>
 <i>indexbyte2</i>
<td><a name="593"></a>
 

<tr><td><a name="851"></a>
 <i>dimensions</i>
<td><a name="600"></a>
 

</Table><br><br><p>
<a name="multianewarray_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12466"></a>
<i>multianewarray_quick</i> = 223 (0xdf)<p>
<a name="multianewarray_quick.Stack"></a>
<b>Stack</h3></b>
<a name="853"></a>
..., <i>count1</i>,<em> </em>[<i>count2</i>, ...]<em> </em><img src="chars/arrwdbrt.gif"> ..., <i>arrayref</i><p>
<a name="multianewarray_quick.Description"></a>
<b>Description</h3></b>
<a name="854"></a>
The <i>dimensions</i> is an unsigned byte which must be greater than or equal to 1. It represents the number of dimensions of the array to be created. The operand stack must contain <i>dimensions</i> words, which must be of type <code>int</code> and nonnegative, each representing the number of components in a dimension of the array to be created. The <i>count1</i> is the desired length in the first dimension, <i>count2</i> in the second, etc.<p>
<a name="8049"></a>
All of the <i>count</i> values are popped off the operand stack. The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The resulting entry must have already been resolved to an array class type of dimensionality greater than or equal to <i>dimensions</i>.<p>
<a name="8024"></a>
A new multidimensional array of the array type is allocated from the garbage-collected heap. The components of the first dimension of the array are initialized to subarrays of the type of second dimension, and so on. The components of the array in the final dimension are initialized to the default initial value for its type (<a href="Concepts.doc.html#15858">&#167;2.5.1</a>). A <code>reference</code> <i>arrayref</i> to the new array is pushed onto the operand stack. <p>

<b>Runtime Exception</h3></b>
<a name="1624"></a>
If any of the <i>dimensions</i> values on the operand stack is less than zero, <i>multianewarray_quick</i> throws a <code>NegativeArraySize</code><code>-Exception</code>.<p>
<a name="multianewarray_quick.Notes"></a>
<b>Notes</h3></b>
<a name="4903"></a>
The opcode of this instruction was originally <i>multianewarray</i>. The operands of the <i>multianewarray</i> instruction are not modified.<p>
<a name="4901"></a>
<p>

<a name="new_quick"></a>
<hr><h2>new_quick</h2>
<a name="new_quick.Operation"></a>
<b>Operation</h3></b>
<a name="7945"></a>
Create new object<p><Table Border="1">
<tr><td><a name="7940"></a>
 <i>new_quick</i>
<td><a name="371"></a>
 

<tr><td><a name="7942"></a>
 <i>indexbyte1</i>
<td><a name="378"></a>
 

<tr><td><a name="7944"></a>
 <i>indexbyte2</i>
<td><a name="385"></a>
 

</Table><br><br><p>
<a name="new_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12467"></a>
<i>new_quick</i> = 221 (0xdd)<p>
<a name="new_quick.Stack"></a>
<b>Stack</h3></b>
<a name="7946"></a>
... <img src="chars/arrwdbrt.gif">  ..., <i>objectref</i><p>
<a name="new_quick.Description"></a>
<b>Description</h3></b>
<a name="7947"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The item at that index must have already been resolved to a class type. A new instance of that class is created, and the instance variables of the new object are initialized to their default initial values (<a href="Concepts.doc.html#15858">&#167;2.5.1</a>). The <i>objectref</i>, a <code>reference</code> to <em>the instance, </em>is pushed onto the operand stack.<p>
<a name="new_quick.Notes"></a>
<b>Notes</h3></b>
<a name="7953"></a>
The opcode of this instruction was originally <i>new</i>. The operands of the original <i>new</i> instruction are not modified.<p>

<a name="putfield_quick"></a>
<hr><h2>putfield_quick</h2>
<a name="putfield_quick.Operation"></a>
<b>Operation</h3></b>
<a name="6789"></a>
Set field in object<p><Table Border="1">
<tr><td><a name="6784"></a>
 <i>putfield_quick</i>
<td><a name="248"></a>
 

<tr><td><a name="6786"></a>
 <i>offset</i>
<td><a name="255"></a>
 

<tr><td><a name="6788"></a>
 <i>unused</i>
<td><a name="262"></a>
 

</Table><br><br><p>
<a name="putfield_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12468"></a>
<i>putfield_quick</i> = 207 (0xcf)<p>
<a name="putfield_quick.Stack"></a>
<b>Stack</h3></b>
<a name="1367"></a>
..., <i>objectref</i>, <i>value</i> <img src="chars/arrwdbrt.gif">  ...<p>
<a name="putfield_quick.Description"></a>
<b>Description</h3></b>
<a name="4914"></a>
The <i>objectref</i>, which m<em>ust be of type </em><code>reference</code>, and <i>value</i>, which m<em>ust be a value of a type appropriate for the specified field, are popped from the </em>operand stack<em>. </em>The <i>value</i> is written at <i>offset</i> into the class instance referenced by <i>objectref</i>.<p>
<a name="putfield_quick.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="4915"></a>
If <i>objectref</i> is <code>null</code>, the <i>putfield_quick</i> instruction throws a <code>NullPointerException</code>.<p>
<a name="putfield_quick.Notes"></a>
<b>Notes</h3></b>
<a name="17325"></a>
The opcode of this instruction was originally <i>putfield</i>, operating on a field determined dynamically to have an offset into the class instance data of 255 words or less and to have a width of one word. <p>
<a name="17425"></a>
When the constant pool entry referenced by a <i>putfield</i> instruction is resolved, the offset for the field it references is generated. That offset replaces the first operand byte of the original <i>putfield</i> instruction. The second operand byte of the <i>putfield</i> is unused in <i>putfield_quick</i>.<p>

<a name="putfield_quick_w"></a>
<hr><h2>putfield_quick_w</h2>
<a name="putfield_quick_w.Operation"></a>
<b>Operation</h3></b>
<a name="6698"></a>
Set field in object<p><Table Border="1">
<tr><td><a name="6693"></a>
 <i>putfield_quick_w</i>
<td><a name="612"></a>
 

<tr><td><a name="6695"></a>
 <i>indexbyte1</i>
<td><a name="619"></a>
 

<tr><td><a name="6697"></a>
 <i>indexbyte2</i>
<td><a name="626"></a>
 

</Table><br><br> (wide index)<p>
<a name="putfield_quick_w.Forms"></a>
<b>Forms</h3></b>
<a name="12469"></a>
<i>putfield_quick_w</i> = 228 (0xe4)<p>
<a name="putfield_quick_w.Stack"></a>
<b>Stack</h3></b>
<a name="6699"></a>
..., <i>objectref</i>, <i>value</i> <img src="chars/arrwdbrt.gif">  ...<p>
<a name="17271"></a>
OR<p>
<a name="putfield_quick_w.Stack"></a>
<b>Stack</h3></b>
<a name="17274"></a>
..., <i>objectref</i>, <i>value.word1</i>, <i>value.word2</i> <img src="chars/arrwdbrt.gif"> ...<p>
<a name="putfield_quick_w.Description"></a>
<b>Description</h3></b>
<a name="6707"></a>
The <i>objectref</i>, which m<em>ust be of type </em><code>reference</code>, and <i>value</i>, which m<em>ust be a value of a type appropriate for the specified field, are popped from the </em>operand stack<em>. The unsigned </em><i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The constant pool item at the index must be a <code>CONSTANT_Fieldref</code> <a href="ClassFile.doc.html#4723">(&#167;4.4.2)</a> which must already have been resolved and must not be a class (<code>static</code>) field. The <i>value</i> is written at <i>offset</i> into the class instance referenced by <i>objectref</i>.<p>
<a name="putfield_quick_w.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="6701"></a>
If <i>objectref</i> is <code>null</code>, the <i>putfield_quick_w</i> instruction throws a <code>NullPointerException</code>.<p>
<a name="putfield_quick_w.Notes"></a>
<b>Notes</h3></b>
<a name="6724"></a>
The opcode of this instruction was originally <i>putfield</i>, operating on a field determined dynamically to have an offset into the class instance data of more than 255 words.<p>

<a name="putfield_quick_w"></a>
<a name="17418"></a>
The operands of the <i>putfield</i> instruction are not modified. Because the <i>putfield_quick_w</i> instruction operates on both one- and two-word wide fields, it needs to know both the field offset and the type of that field. Because the original <i>putfield</i> instruction needed a 16-bit index, the field offset may be 16 bits wide. As there is insufficient space in the instruction to store both a 16-bit offset and a field type, <i>putfield_quick_w</i> retains its original operands and uses them to index into the constant pool, where the offset and field type are available in the resolved entry.<p>

<a name="putfield2_quick"></a>
<hr><h2>putfield2_quick</h2>
<a name="putfield2_quick.Operation"></a>
<b>Operation</h3></b>
<a name="6806"></a>
Set <code>long</code> or <code>double</code> field in object<p><Table Border="1">
<tr><td><a name="6801"></a>
 <i>putfield2_quick</i>
<td><a name="449"></a>
 

<tr><td><a name="6803"></a>
 <i>offset</i>
<td><a name="456"></a>
 

<tr><td><a name="6805"></a>
 <i>unused</i>
<td><a name="463"></a>
 

</Table><br><br><p>
<a name="putfield2_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12470"></a>
<i>putfield2_quick</i> = 209 (0xd1)<p>
<a name="putfield2_quick.Stack"></a>
<b>Stack</h3></b>
<a name="6807"></a>
..., <i>objectref</i>, <i>value.word1</i>, <i>value.word2 </i><img src="chars/arrwdbrt.gif">  ...<p>
<a name="putfield2_quick.Description"></a>
<b>Description</h3></b>
<a name="6919"></a>
The <i>objectref</i>, which m<em>ust be of type </em><code>reference</code>, and <i>value</i>, which m<em>ust be a value of a type appropriate for the specified field, are popped from the </em>operand stack<em>. The </em><i>value</i> is written at <i>offset</i> into the class instance referenced by <i>objectref</i>.<p>
<a name="putfield2_quick.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="6809"></a>
If <i>objectref</i> is <code>null</code>, the <i>putfield2_quick</i> instruction throws a <code>NullPointerException</code>.<p>
<a name="putfield2_quick.Notes"></a>
<b>Notes</h3></b>
<a name="6448"></a>
The opcode of this instruction was originally <i>putfield</i>, operating on a field determined dynamically to have an offset into the class instance data of 255 words or less and to have a width of two words. <p>
<a name="17424"></a>
When the constant pool entry referenced by a <i>putfield</i> instruction is resolved, the offset for the field it references is generated. That offset replaces the first operand of the original <i>putfield</i> instruction. The second operand of the <i>putfield</i> is unused by <i>putfield2_quick</i>.<p>

<a name="putstatic_quick"></a>
<hr><h2>putstatic_quick</h2>
<a name="putstatic_quick.Operation"></a>
<b>Operation</h3></b>
<a name="9140"></a>
Set <code>static</code> field in class<p><Table Border="1">
<tr><td><a name="9135"></a>
 <i>putstatic_quick</i>
<td><a name="274"></a>
 

<tr><td><a name="9137"></a>
 <i>indexbyte1</i>
<td><a name="281"></a>
 

<tr><td><a name="9139"></a>
 <i>indexbyte2</i>
<td><a name="288"></a>
 

</Table><br><br><p>
<a name="putstatic_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12471"></a>
<i>putstatic_quick</i> = 211 (0xd3)<p>
<a name="putstatic_quick.Stack"></a>
<b>Stack</h3></b>
<a name="9141"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif">  ...<p>
<a name="putstatic_quick.Description"></a>
<b>Description</h3></b>
<a name="9142"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a> where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The constant pool item must be a field reference to a class (<code>static</code>) field that must have already been successfully resolved to a type that is one word wide. The <i>value</i> must be of a type appropriate to that class field. The <i>value</i> is popped from the operand stack, and that class field is set to <i>value</i>.<p>
<a name="putstatic_quick.Notes"></a>
<b>Notes</h3></b>
<a name="8619"></a>
The opcode of this instruction was originally <i>putstatic</i>, operating on a <code>static</code> field determined dynamically to be one word wide. The operands of the <i>putstatic</i> instruction are not modified. There is no equivalent to the <i>putfield_quick</i> instruction, storing a class offset as an instruction operand, for one-word <code>static</code> fields.<p>
<a name="8617"></a>
<p>

<a name="putstatic2_quick"></a>
<hr><h2>putstatic2_quick</h2>
<a name="putstatic2_quick.Operation"></a>
<b>Operation</h3></b>
<a name="9157"></a>
Set <code>static</code> field in class<p><Table Border="1">
<tr><td><a name="9152"></a>
 <i>putstatic2_quick</i>
<td><a name="501"></a>
 

<tr><td><a name="9154"></a>
 <i>indexbyte1</i>
<td><a name="508"></a>
 

<tr><td><a name="9156"></a>
 <i>indexbyte2</i>
<td><a name="515"></a>
 

</Table><br><br><p>
<a name="putstatic2_quick.Forms"></a>
<b>Forms</h3></b>
<a name="12472"></a>
<i>putstatic2_quick</i> = 213 (0xd5)<p>
<a name="putstatic2_quick.Stack"></a>
<b>Stack</h3></b>
<a name="9158"></a>
..., <i>value.word1</i>, <i>value.word2</i> <img src="chars/arrwdbrt.gif"> ...<p>
<a name="putstatic2_quick.Description"></a>
<b>Description</h3></b>
<a name="9159"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are used to construct an index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The constant pool item must be a field reference to a class (<code>static</code>) field that must have already been successfully resolved to a type that is two words wide. The <i>value</i> must be of a type appropriate to that class field. The <i>value</i> is popped from the operand stack, and that class field is set to <i>value</i>.<p>
<a name="putstatic2_quick.Notes"></a>
<b>Notes</h3></b>
<a name="8639"></a>
The opcode of this instruction was originally <i>putstatic</i>, operating on a <code>static</code> field determined dynamically to be two words wide. The operands of the <i>putstatic</i> instruction are not modified. There is no equivalent to the <i>putfield2_quick</i> instruction, storing a class offset as an instruction operand, for two-word <code>static</code> fields.<p>


<hr>
<!-- This inserts footnotes--><p>
<br>
<a href="VMSpecTOC.doc.html">Contents</a> | <a href="Quick.doc.html">Prev</a> | <a href="Mnemonics.doc.html">Next</a> | <a href="Lindholm.INDEX.html">Index</a>
<p>
<font size="-1"><i>Java Virtual Machine Specification </i><br>
<!-- HTML generated by dkramer on May 05, 1997 -->
<i><a href="copyright.doc.html">Copyright &#169 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jvm@java.sun.com">jvm@java.sun.com</a>
</font>
</body></html>
