<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>VM Spec  Compiling for the  Java Virtual Machine</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
<table width=100%><tr>
<td><a href="VMSpecTOC.doc.html">Contents</a> | <a href="Instructions2.doc15.html">Prev</a> | <a href="Threads.doc.html">Next</a> | <a href="Lindholm.INDEX.html">Index</a></td><td align=right><i><i>The Java<sup><font size=-2>TM</font></sup> Virtual Machine Specification</i></i></td>
</tr></table>


<hr><br>
 
<a name="2839"></a>
<p><strong>CHAPTER 7 </strong></p>
<a name="2989"></a>
<h1>Compiling for the  Java Virtual Machine</h1>
<hr><p>
<a name="6043"></a>
<p>
<a name="4028"></a>
The Java Virtual Machine is designed to support the Java programming language. 
Sun's JDK 1.0.2 release of the Java programming language contains both a compiler 
from Java source code to the Java Virtual Machine's instruction set (<code>javac</code>) and a 
runtime system that implements the Java Virtual Machine itself (<code>java</code>). Understanding how one Java compiler utilizes the Java Virtual Machine is useful to the prospective Java compiler writer, as well as to one trying to understand the operation of the 
Java Virtual Machine.
<p><a name="4054"></a>
Although this chapter concentrates on compiling Java code, the Java Virtual Machine does not assume that the instructions it executes were generated from Java source code. While there have been a number of efforts aimed at compiling other languages to the Java Virtual Machine, version 1.0.2 of the Java Virtual Machine was not designed to support a wide range of languages. Some languages may be hosted fairly directly by the Java Virtual Machine. Others may support constructs that only can be implemented inefficiently. <p>
<a name="9588"></a>
We are considering bounded extensions to future versions of the Java Virtual Machine to support a wider range of languages more directly. Please contact us at <code>jvm@javasoft.com</code> if you have interest in this effort.<p>
<a name="11072"></a>
Note that the term "compiler" is sometimes used when referring to a translator from the instruction set of a Java Virtual Machine to the instruction set of a specific CPU. One example of such a translator is a "Just In Time" (JIT) code generator, which generates platform-specific instructions only after Java Virtual Machine code has been loaded into the Java Virtual Machine. This chapter does not address issues associated with code generation, only those associated with compiling from Java source code to Java Virtual Machine instructions.<p>
<a name="4083"></a>
<hr><h2>7.1	 Format of Examples</h2>
<a name="11107"></a>
This chapter consists mainly of examples of Java source code together with annotated listings of the Java Virtual Machine code that the <code>javac</code> compiler in Sun's JDK 
1.0.2 release generates for the examples. The Java Virtual Machine code is written 
in the informal "virtual machine assembly language" output by Sun's <code>javap</code> utility, 
also distributed with the JDK. You can use <code>javap</code> to generate additional examples of 
compiled Java methods.
<p><a name="10062"></a>
The format of the examples should be familiar to anyone who has read assembly code. Each instruction takes the form<p>
<pre><br><a name="4190"></a>&nbsp;&nbsp;&nbsp;&nbsp;<i>&lt;index&gt; &lt;opcode&gt;</i> [<i>&lt;operand1&gt; </i>[<i>&lt;operand2&gt;...</i>]]<i> </i>[<i>&lt;comment&gt;]
</i></pre><a name="6265"></a>
The <i>&lt;index&gt;</i> is the index of the opcode of the instruction in the array that contains 
the bytes of Java Virtual Machine code for this method. Alternatively, the <i>&lt;index&gt;</i> 
may be thought of as a byte offset from the beginning of the method. The <i>&lt;opcode&gt;</i> 
is the mnemonic for the instruction's opcode, and the zero or more <i>&lt;operandN&gt;</i> are 
the operands of the instruction. The optional <i>&lt;comment&gt;</i> is given in Java-style end-
of-line comment syntax:<p><Table Border="0">
<tr><td>          <i>8 
</i><br><td>          <i>bipush 100
</i><br><td><i>// Push constant </i><code>100
</code>
</Table><br><br>
<p><a name="8694"></a>
Some of the material in the comments is emitted by <code>javap</code>; the rest is supplied by the 
authors. The <i>&lt;index&gt;</i> prefacing each instruction may be used as the target of a control transfer instruction. For instance, a <i>goto 8</i> instruction transfers control to the 
instruction at index 8. Note that the actual operands of Java Virtual Machine control 
transfer instructions are offsets from the addresses of the opcodes of those instructions; these operands are displayed by <code>javap</code>, and are shown in this chapter, as more 
easily read offsets into their methods.
<p><a name="14270"></a>
We preface an operand representing a constant pool index with a hash sign, and follow the instruction by a comment identifying the constant pool item referenced, as in<p><Table Border="0">
<tr><td>          <i>10 
</i><br><td>          <i>ldc #1 
</i><br><td><i>// Float </i><code>100.</code><i>000000
</i>
</Table><br><br><p>
<a name="14286"></a>
<p>
<a name="14330"></a>
or<p><Table Border="0">
<tr><td>          <i>9 
</i><br><td>          <i>invokevirtual 
#4
</i><br><td><i>// Method Example</i><code>.addTwo(II)I
</code>
</Table><br><br>
<p><a name="14332"></a>
For the purposes of this chapter, we do not worry about specifying details such as 
operand sizes.
<p><a name="4182"></a>
<hr><h2>7.2	 Use of Constants, Local Variables, and Control Constructs</h2>
<a name="7213"></a>
Java Virtual Machine code exhibits a set of general characteristics imposed by the 
Java Virtual Machine's design and use of types. In the first example we encounter 
many of these, and we consider them in some detail.
<p><a name="4154"></a>
The <code>spin</code> method simply spins around an empty <code>for</code> loop 100 times:<p>
<pre><br><a name="4115"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void spin() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	int i;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	for (i = 0; i &lt; 100; i++) {
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;</code><code> &nbsp; &nbsp;// Loop body is empty</code>
&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="4118"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="4112"></a>
The Java compiler compiles <code>spin</code> to<p>
<a name="14050"></a>
 <i>Method </i><code>void</code> <code>spin()<p><Table Border="0">
<tr><td>             0
<br><td>          <code>iconst_0
</code><br><td><i>// Push </i><code>int</code><i> constant </i><code>0
</code>
<tr><td>          <i>   1 
</i><br><td>          <code>istore_1
</code><br><td><i>// Store into local 1 (</i><code>i</code>=<code>0</code><i>)
</i>
<tr><td>          <i>   2
</i><br><td>          <code>goto 8
</code><br><td><i>// First time through don't increment
</i>
<tr><td>          <i>   5
</i><br><td>          <code>iinc 1 1
</code><br><td><i>// Increment local 1 by 1 (</i><code>i++</code><i>)
</i>
<tr><td>          <i>   8
</i><br><td>          <code>iload_1
</code><br><td><i>// Push local 1 (</i><code>i</code><i>)
</i>
<tr><td>          <i>   9
</i><br><td>          <code>bipush 100
</code><br><td><i>// Push </i><code>int</code><i> constant (</i><code>100</code><i>)
</i>
<tr><td>          <i>  11
</i><br><td>          <code>if_icmplt 5
</code><br><td><i>// Compare, loop if </i><<i> (</i><code>i </code>< <code>100</code><i>)
</i>
<tr><td>          <i>  14
</i><br><td>          <code>return
</code><br><td><i>// Return </i><code>void</code><i> when done
</i>
</Table><br><br></code><p>
<a name="14059"></a>
The Java Virtual Machine is stack-oriented, with most operations taking one or more operands from the operand stack of the Java Virtual Machine's current frame, or pushing results back onto the operand stack. A new frame is created each time a Java method is invoked, and with it is created a new operand stack and set of local variables for use by that method (see <a href="Overview.doc.html#17257">Section 3.6, "Frames"</a>). At any one point of the computation, there are thus likely to be many frames and equally many operand stacks per thread of control, corresponding to many nested method invocations. Only the operand stack in the current frame is active. <p>
<a name="4169"></a>
The instruction set of the Java Virtual Machine distinguishes operand types by using distinct bytecodes for operations on its various data types. The method <code>spin</code> only operates on values of type <code>int</code>. The instructions in its compiled code chosen to operate on typed data (<i>iconst_0</i>, <i>istore_1</i>, <i>iinc</i>, <i>iload_1</i>, <i>if_icmplt</i>) are all specialized for type <code>int</code>.<p>
<a name="4172"></a>
The two constants in <code>spin</code>, <code>0</code> and <code>100</code>, are pushed onto the operand stack using two different instructions. The <code>0</code> is pushed using an <i>iconst_0</i> instruction, one of the family of <i>iconst_&lt;i&gt;</i> instructions. The <code>100</code> is pushed using a <i>bipush</i> instruction, which fetches the value it pushes as an immediate operand.<p>
<a name="4926"></a>
The Java Virtual Machine frequently takes advantage of the likelihood of certain operands (<code>int</code> constants -<i>1</i>, <i>0</i>, <i>1</i>, <i>2</i>, <i>3</i>, <i>4</i> and <i>5</i> in the case of the <i>iconst_&lt;i&gt;</i> instructions) by making those operands implicit in the opcode. Because the <i>iconst_0</i> instruction knows it is going to push an <code>int</code><i> </i><code>0</code>, <i>iconst_0</i> does not need to store an operand to tell it what value to push, nor does it need to fetch or decode an operand. Compiling the push of <code>0</code> as <i>bipush 0</i> would have been correct, but would have made the compiled code for <code>spin</code> one byte longer. A simple virtual machine would have also spent additional time fetching and decoding the explicit operand each time around the loop. Use of implicit operands makes compiled code more compact and efficient. <p>
<a name="4163"></a>
The <code>int</code><i> </i><code>i</code> in <code>spin</code> is stored as Java Virtual Machine local variable <i>1</i>. Because most Java Virtual Machine instructions operate on values popped from the operand stack rather than directly on local variables, instructions that transfer values between local variables and the operand stack are common in code compiled for the Java Virtual Machine. These operations also have special support in the instruction set. In <code>spin</code>, values are transferred to and from local variables using the <i>istore_1</i> and <i>iload_1</i> instructions, each of which implicitly operates on local variable <i>1</i>. The <i>istore_1</i> instruction pops an <code>int</code> from the operand stack and stores it in local variable <i>1</i>. The <i>iload_1</i> instruction pushes the value in local variable <i>1</i> onto the operand stack.<p>
<a name="4941"></a>
The use (and reuse) of local variables is the responsibility of the compiler writer. The specialized load and store instructions should encourage the compiler writer to reuse local variables as much as is feasible. The resulting code is faster, more compact, and uses less space in the Java frame.<p>
<a name="4179"></a>
Certain very frequent operations on local variables are catered to specially by the Java Virtual Machine. The <i>iinc</i> instruction increments the contents of a local variable by a one-byte signed value. The <i>iinc</i> instruction in <code>spin</code> increments the first local variable (its first operand) by <i>1</i> (its second operand). The <i>iinc</i> instruction is very handy when implementing looping constructs. <p>
<a name="12225"></a>
The <code>for</code> loop of <code>spin</code> is accomplished mainly by these instructions:<p><Table Border="0">
<tr><td>          <i>   5
</i><br><td>          <i>iinc 1 1
</i><br><td><i>// Increment local 1 by 1 (i++)
</i>
<tr><td>          <i>   8
</i><br><td>          <i>iload_1
</i><br><td><i>// Push local 1 (i)
</i>
<tr><td>          <i>   9
</i><br><td>          <i>bipush 100
</i><br><td><i>// Push int constant (100)
</i>
<tr><td>          <i>  11
</i><br><td>          <i>if_icmplt 5
</i><br><td><i>// Compare, loop if &lt; (i &lt; 100)
</i>
</Table><br><br><p>
<a name="4207"></a>
The <i>bipush</i> instruction pushes the value <i>100</i> onto the operand stack as an <code>int</code>, then 
the <i>if_icmplt</i> instruction pops that value off the stack and compares it against <i>i</i>. If 
the comparison succeeds (the Java variable <code>i</code> is less than <code>100</code>), control is transferred 
to index <i>5</i> and the next iteration of the <code>for</code> loop begins. Otherwise, control passes to 
the instruction following the <i>if_icmplt</i>.
<p><a name="24512"></a>
If the <code>spin</code> example had used a data type other than <code>int</code> for the loop counter, the compiled code would necessarily change to reflect the different data type. For instance, if instead of an <code>int</code> the <code>spin</code> example uses a <code>double</code>:<p>
<pre><br><a name="24513"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void dspin() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	double i;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	for (i = 0.0; i &lt; 100.0; i++) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	 &#32; &#32; &#32; &#32; &#32; &#32; &#32;;	 &#32; &#32; &#32;// Loop body is empty
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="24518"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="24519"></a>
the compiled code is
<p><a name="6881"></a>
 <i>Method </i><code>void</code> d<code>spin()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>dconst_0
</i><br><td><i>// Push double constant 0.0
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>dstore_1
</i><br><td><i>// Store into locals 1 and 2 (i = 0.0)
</i>
<tr><td>          <i>   2 
</i><br><td>          <i>goto 9
</i><br><td><i>// First time through don't increment
</i>
<tr><td>          <i>   5 
</i><br><td>          <i>dload_1
</i><br><td><i>// Push double onto operand stack
</i>
<tr><td>          <i>   6 
</i><br><td>          <i>dconst_1
</i><br><td><i>// Push double constant 1 onto stack
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>dadd
</i><br><td><i>// Add; there is no dinc instruction
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>dstore_1
</i><br><td><i>// Store result in locals 1 and 2
</i>
<tr><td>          <i>   9 
</i><br><td>          <i>dload_1
</i><br><td><i>// Push local
</i>
<tr><td>          <i>  10 
</i><br><td>          <i>ldc2_w #4 
</i><br><td><i>// Double 100.000000
</i>
<tr><td>          <i>  13 
</i><br><td>          <i>dcmpg
</i><br><td><i>// There is no if_dcmplt instruction
</i>
<tr><td>          <i>  14 
</i><br><td>          <i>iflt 5
</i><br><td><i>// Compare, loop if &lt; (i &lt; 100.000000)
</i>
<tr><td>          <i>  17 
</i><br><td>          <i>return
</i><br><td><i>// Return void when done
</i>
</Table><br><br></code><p>
<a name="4181"></a>
The instructions that operate on typed data are now specialized for type <code>double</code>. (The 
<i>ldc2_w</i> instruction will be discussed later in this chapter.)
<p><a name="24112"></a>
Note that in <code>dspin</code>, <code>double</code> values use two words of storage, whether on the operand stack or in local variables. This is also the case for values of type <code>long</code>. As another example:<p>
<pre><br><a name="24113"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>double doubleLocals(double d1, double d2) {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return d1 + d2;
</code><a name="24115"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="24116"></a>
becomes
<p><a name="10234"></a>
 <i>Method </i><code>double</code> <code>doubleLocals(double,double)<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>dload_1
</i><br><td><i>// First argument in locals 1 and 2
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>dload_3
</i><br><td><i>// Second argument in locals 3 and 4
</i>
<tr><td>          <i>   2 
</i><br><td>          <i>dadd
</i><br><td><i>// Each also uses two words on stack
</i>
<tr><td>          <i>   3 
</i><br><td>          <i>dreturn
</i><br><td>          
<br>
</Table><br><br></code><p>
<a name="10226"></a>
It is always necessary to access the words of a two-word type in pairs and in their original order. For instance, the words of the <code>double</code> values in <code>doubleLocals</code> must never be manipulated individually.<p>
<a name="7349"></a>
The Java Virtual Machine's opcode size of one byte results in its compiled code being very compact. However, one-byte opcodes also mean that the Java Virtual Machine's instruction set must stay small. As a compromise, the Java Virtual Machine does not provide equal support for all data types: it is not completely orthogonal (see <a href="Overview.doc.html#23711">Table 3.1, "Type support in the Java Virtual Machine instruction set"</a>). In the case of <code>dspin</code>, note that there is no <i>if_dcmplt</i> instruction in the Java Virtual Machine instruction set. Instead, the comparison must be performed using a <i>dcmpg</i> followed by an <i>iflt</i>, requiring one more Java Virtual Machine instruction than the <code>int</code> version of <code>spin</code>.<p>
<a name="4595"></a>
The Java Virtual Machine provides the most direct support for data of type <code>int</code>. This is partly because the Java Virtual Machine's operand stack and local variables are one word wide, and a word is guaranteed to hold values of all integral types up to and including an <code>int</code> value. It is also motivated by the frequency of <code>int</code> data in typical Java programs.<p>
<a name="24533"></a>
Smaller integral types have less direct support. There are no <code>byte</code>, <code>char</code>, or <code>short</code> versions of the store, load, or add instructions, for instance. Here is the <code>spin</code> example written using a <code>short</code>:<p>
<pre><br><a name="24537"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void sspin() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	short i;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	for (i = 0; i &lt; 100; i++) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    ;		// Loop body is empty
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="24542"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="24535"></a>
<p>
<a name="24534"></a>
It must be compiled for the Java Virtual Machine using instructions operating on 
another type, most likely <code>int</code>, converting between <code>short</code> and <code>int</code> values as necessary 
to ensure that the results of operations on <code>short</code> data stay within the appropriate 
range:
<p><a name="4277"></a>
 <i>method </i><code>void</code> <code>sspin()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>iconst_0
</i><br><td>

<tr><td>          <i>   1 
</i><br><td>          <i>istore_1
</i><br><td>

<tr><td>          <i>   2 
</i><br><td>          <i>goto 10
</i><br><td>

<tr><td>          <i>   5 
</i><br><td>          <i>iload_1
</i><br><td><i>// The </i><code>short</code><i> is stored in an </i><code>int
</code>
<tr><td>          <i>   6 
</i><br><td>          <i>iconst_1
</i><br><td>

<tr><td>          <i>   7
</i><br><td>          <i>iadd
</i><br><td>

<tr><td>          <i>   8 
</i><br><td>          <i>i2s
</i><br><td><i>// Truncate </i><code>int</code><i> to </i><code>short
</code>
<tr><td>          <i>   9 
</i><br><td>          <i>istore_1
</i><br><td>

<tr><td>          <i>  10 
</i><br><td>          <i>iload_1
</i><br><td>

<tr><td>          <i>  11 
</i><br><td>          <i>bipush 100
</i><br><td>

<tr><td>          <i>  13 
</i><br><td>          <i>if_icmplt 5
</i><br><td>

<tr><td>          <i>  16 
</i><br><td>          <i>return
</i><br><td>

</Table><br><br></code><p>
<a name="4589"></a>
The lack of direct support for <code>byte</code>, <code>char</code>, and <code>short</code> types in the Java Virtual Machine is 
not particularly painful, because values of those types are internally promoted to <code>int</code> 
(<code>byte</code> and <code>short</code> are sign-extended to <code>int</code>, <code>char</code> is zero-extended). Operations on <code>byte</code>, 
<code>char</code>, and <code>short</code> data can thus be done using <code>int</code> instructions. The only additional cost is 
that of truncating the values of <code>int</code> operations to valid ranges. 
<p><a name="5831"></a>
The <code>long</code> and floating-point types have an intermediate level of support in the Java Virtual Machine, lacking only the full complement of conditional control transfer instructions. <p>
<a name="4228"></a>
<hr><h2>7.3	 Arithmetic</h2>
<a name="4307"></a>
The Java Virtual Machine generally does arithmetic on its operand stack (the exception is the <i>iinc</i> instruction, which directly increments the value of a local variable). 
For instance, the <code>align2grain</code> method aligns an <code>int</code> value to a given power of 2 grain 
size:
<p><pre><br><a name="4310"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>int align2grain(int i, int grain) {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return ((i + grain-1) &amp; ~(grain-1));
</code><a name="4312"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="9749"></a>
Operands for arithmetic operations are popped from the operand stack, and the results of operations are pushed back onto the operand stack. Results of arithmetic subcomputations can thus be made available as operands of their nesting computation. For instance, the calculation of <code>~(grain</code>-<code>1)</code> is handled by these instructions:<p><Table Border="0">
<tr><td>          <i>   5 
</i><br><td>          <i>iload_2
</i><br><td><i>// Load </i><code>grain</code><i> onto operand stack
</i>
<tr><td>          <i>   6 
</i><br><td>          <i>iconst_1
</i><br><td><i>// Load constant </i><code>1</code><i> onto operand stack
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>isub
</i><br><td><i>// Subtract; push result onto stack
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>iconst_m1
</i><br><td><i>// Load constant </i>-<code>1</code><i> onto operand stack
</i>
<tr><td>          <i>   9 
</i><br><td>          <i>ixor
</i><br><td><i>// Do XOR; push result onto stack
</i>
</Table><br><br><p>
<a name="9756"></a>
First <code>grain</code>-<code>1</code> is calculated using the contents of local variable <i>2</i> and an immediate <code>int</code> value <code>1</code>. These operands are popped from the operand stack and their difference pushed back onto the operand stack, where it is immediately available 
for use as one operand of the <i>ixor</i> instruction (recall that <code>~x</code> == -<code>1^x</code>). Similarly, 
the result of the <i>ixor</i> instruction becomes an operand for the subsequent <i>iand</i> 
instruction.
<p><a name="9759"></a>
The code for the entire method follows:<p>
<a name="6983"></a>
 <i>Method </i><code>int</code> <code>align2grain(int,int)<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td><i>iload_1
</i>
<tr><td>          <i>   1 
</i><br><td><i>iload_2
</i>
<tr><td>          <i>   2 
</i><br><td><i>iadd
</i>
<tr><td>          <i>   3 
</i><br><td><i>iconst_1
</i>
<tr><td>          <i>   4 
</i><br><td><i>isub
</i>
<tr><td>          <i>   5 
</i><br><td><i>iload_2
</i>
<tr><td>          <i>   6 
</i><br><td><i>iconst_1
</i>
<tr><td>          <i>   7 
</i><br><td><i>isub
</i>
<tr><td>          <i>   8 
</i><br><td><i>iconst_m1
</i>
<tr><td>          <i>   9 
</i><br><td><i>ixor
</i>
<tr><td>          <i>  10
</i><br><td><i>iand
</i>
<tr><td>          <i>  11
</i><br><td><i>ireturn
</i>
</Table><br><br></code><p>
<a name="5841"></a>
<hr><h2>7.4	 Accessing the Constant Pool</h2>
<a name="6040"></a>
Many numeric constants, as well as objects, fields, and methods, are accessed via 
the constant pool of the current class. Object access is considered later <a href="Compiling.doc.html#4089">(&#167;7.8)</a>. Java 
data of types <code>int</code>, <code>long</code>, <code>float</code>, and <code>double</code>, as well as references to instances of <code>String</code> 
(constant pool items tagged <code>CONSTANT_String</code>), is managed using the <i>ldc</i>, <i>ldc_w</i>, 
and <i>ldc2_w</i> instructions. 
<p><a name="6072"></a>
The <i>ldc</i> and <i>ldc_w</i> instructions are used to access one-word values in the constant pool (including instances of class <code>String</code>), and <i>ldc2_w</i> is used to access two-word values. The <i>ldc_w</i> instruction is used in place of <i>ldc</i> only when there is a large number of constant pool items and a larger index is needed to access an item. The <i>ldc2_w</i> instruction is used to access all two-word items; there is no non-wide variant.<p>
<a name="6073"></a>
Integral constants of types <code>byte</code>, <code>char</code>, or <code>short</code>, as well as small <code>int</code> values, may be compiled using the <i>bipush</i>, <i>sipush</i>, or <i>iconst_&lt;i&gt;</i> instructions, as seen earlier <a href="Compiling.doc.html#4182">(&#167;7.2)</a>. Certain small floating-point constants may be compiled using the <i>fconst_&lt;f&gt;</i> and <i>dconst_&lt;d&gt;</i> instructions. <p>
<a name="24477"></a>
In all of these cases compilation is straightforward. For instance, the constants for<p>
<pre><br><a name="24478"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void useManyNumeric() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	int i = 100;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	int j = 1000000;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	long l1 = 1;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	long l2 = 0xffffffff;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	double d = 2.2;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	...do some calculations...
</code><a name="24485"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="24486"></a>
are set up as follows:
<p><a name="15336"></a>
 <i>Method </i><code>void</code> <code>useManyNumeric()<p><Table Border="0">
<tr><td>          <i>   0
</i><br><td>          <i>bipush 100
</i><br><td><i>// Push a small </i><code>int</code><i> with bipush
</i>
<tr><td>          <i>   2
</i><br><td>          <i>istore_1
</i><br><td>

<tr><td>          <i>   3 
</i><br><td>          <i>ldc #1 
</i><br><td><i>// Integer </i><code>1000000</code><i>; a larger </i><code>int
</code>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// value uses ldc
</i>
<tr><td>          <i>   5 
</i><br><td>          <i>istore_2
</i><br><td>

<tr><td>          <i>   6 
</i><br><td>          <i>lconst_1
</i><br><td><i>// A tiny </i><code>long</code><i> value uses short, fast lconst_1
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>lstore_3
</i><br><td>

<tr><td>          <i>   8
</i><br><td>          <i>ldc2_w #6 
</i><br><td><i>// A </i><code>long</code><i> </i><code>0xffffffff</code><i> (that is, an </i><code>int</code><i> </i><code>-1</code><i>); any
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// </i><code>long</code><i> constant value can be pushed by 
ldc2_w
</i>
<tr><td>          <i>  11
</i><br><td>          <i>lstore 5
</i><br><td>

<tr><td>          <i>  13 
</i><br><td>          <i>ldc2_w #8 
</i><br><td><i>// Double </i><code>2.200000</code><i>; so do
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// uncommon </i><code>double</code><i> values
</i>
<tr><td>          <i>  16 
</i><br><td>          <i>dstore 7
</i><br><td>

</Table><br><br></code><p>
<pre><a name="15252"></a>&nbsp;&nbsp;&nbsp;&nbsp;<i>...do those calculations...
</i><br></pre><a name="8478"></a>
<hr><h2>7.5	 More Control Examples</h2>
<a name="8479"></a>
Compilation of Java's <code>for</code> statement was shown in an earlier section <a href="Compiling.doc.html#4182">(&#167;7.2)</a>. Most of 
Java's other intramethod control transfer constructs (<code>if-then-else</code>, <code>do</code>, <code>while</code>, <code>break</code>, and 
<code>continue</code>) are also compiled in the obvious ways. The compilation of Java's <code>switch</code> statement is handled in a separate section (<a href="Compiling.doc.html#4095">Section 7.10, "Compiling Switches"</a>), as is the 
compilation of exceptions (<a href="Compiling.doc.html#9934">Section 7.12, "Throwing and Handling Exceptions"</a>) and 
Java's <code>finally</code> statement (<a href="Compiling.doc.html#13789">Section 7.13, "Compiling finally"</a>).
<p><a name="8489"></a>
As a further example, a <code>while</code> loop is compiled in an obvious way, although the specific control transfer instructions made available by the Java Virtual Machine vary by data type. As usual, there is more support for data of type <code>int</code>:<p>
<pre><br><a name="8490"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void whileInt() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	int i = 0;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	while (i &lt; 100) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    i++;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="8495"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="8497"></a>
is compiled to
<p><a name="8498"></a>
 <i>Method </i><code>void</code> <code>whileInt()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td><i>iconst_0
</i>
<tr><td>          <i>   1 
</i><br><td><i>istore_1
</i>
<tr><td>          <i>   2 
</i><br><td><i>goto 8
</i>
<tr><td>          <i>   5 
</i><br><td><i>iinc 1 1
</i>
<tr><td>          <i>   8 
</i><br><td><i>iload_1
</i>
<tr><td>          <i>   9 
</i><br><td><i>bipush 100
</i>
<tr><td>          <i>  11 
</i><br><td><i>if_icmplt 5
</i>
<tr><td>          <i>  14 
</i><br><td><i>return
</i>
</Table><br><br></code><p>
<a name="8508"></a>
Note that the test of the <code>while</code> statement (implemented using the <i>if_icmplt</i> instruction) is at the bottom of the Java Virtual Machine code for the loop. (This was also the case in the <code>spin</code> examples earlier.) The test being at the bottom of the loop forces the use of a <i>goto</i> instruction to get to the test prior to the first iteration of the loop. If that test fails, and the loop body is never entered, this extra instruction is wasted. However, <code>while</code> loops are typically used when their body is expected to be run, often for many iterations. For subsequent iterations, putting the test at the bottom of the loop saves a Java Virtual Machine instruction each time around the loop: if the test were at the top of the loop, the loop body would need a trailing <i>goto</i> instruction to get back to the top.<p>
<a name="8700"></a>
Control constructs involving other data types are compiled in similar ways, but must use the instructions available for those data types. This leads to somewhat less efficient code because more Java Virtual Machine instructions are needed:<p>
<pre><br><a name="8509"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void whileDouble() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	double i = 0.0;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	while (i &lt; 100.1) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    i++;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="8514"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="8516"></a>
is compiled to
<p><a name="15354"></a>
 <i>Method </i><code>void</code> <code>whileDouble()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>dconst_0
</i><br><td>

<tr><td>          <i>   1 
</i><br><td>          <i>dstore_1
</i><br><td>

<tr><td>          <i>   2 
</i><br><td>          <i>goto 9
</i><br><td>

<tr><td>          <i>   5 
</i><br><td>          <i>dload_1
</i><br><td>

<tr><td>          <i>   6 
</i><br><td>          <i>dconst_1
</i><br><td>

<tr><td>          <i>   7 
</i><br><td>          <i>dadd
</i><br><td>

<tr><td>          <i>   8 
</i><br><td>          <i>dstore_1
</i><br><td>

<tr><td>          <i>   9 
</i><br><td>          <i>dload_1
</i><br><td>

<tr><td>          <i>  10 
</i><br><td>          <i>ldc2_w #4 
</i><br><td><i>// Double </i><code>100.100000
</code>
<tr><td>          <i>  13 
</i><br><td>          <i>dcmpg
</i><br><td><i>// To test we have to use
</i>
<tr><td>          <i>  14 
</i><br><td>          <i>iflt 5
</i><br><td><i>// two instructions...
</i>
<tr><td>          <i>  17 
</i><br><td>          <i>return
</i><br><td>

</Table><br><br></code><p>
<a name="8555"></a>
Each floating-point type has two comparison instructions: <i>fcmpl</i> and <i>fcmpg</i> for type <code>float</code>, and <i>dcmpl</i> and <i>dcmpg</i> for type <code>double</code>. The variants differ only in their treatment of NaN. NaN is unordered, so all floating-point comparisons fail if either of their operands is NaN. The compiler chooses the variant of the comparison instruction for the appropriate type that produces the same result whether the comparison fails on non-NaN values or encounters a NaN. For instance:<p>
<pre><br><a name="8563"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>int lessThan100(double d) {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	if (d &lt; 100.0) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    return 1;				
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	} else {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    return -1;				
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="8569"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="8594"></a>
compiles to
<p><a name="8571"></a>
 <i>Method </i><code>int</code> <code>lessThan100(double)<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>dload_1
</i><br><td>

<tr><td>          <i>   1 
</i><br><td>          <i>ldc2_w #4 
</i><br><td><i>// Double </i><code>100.000000
</code>
<tr><td>          <i>   4 
</i><br><td>          <i>dcmpg
</i><br><td><i>// Push 1 if </i><code>d</code><i> is NaN or </i><code>d</code><i> </i>\> <code>100.000000</code><i>;
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// push 0 if </i><code>d</code><i> == </i><code>100.000000
</code>
<tr><td>          <i>   5 
</i><br><td>          <i>ifge 10
</i><br><td><i>// Branch on 0 or 1
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>iconst_1
</i><br><td>

<tr><td>          <i>   9 
</i><br><td>          <i>ireturn
</i><br><td>

<tr><td>          <i>  10 
</i><br><td>          <i>iconst_m1
</i><br><td>

<tr><td>          <i>  11 
</i><br><td>          <i>ireturn
</i><br><td>

</Table><br><br></code><p>
<a name="8595"></a>
If <code>d</code> is not NaN and is less than <code>100.0</code>, the <i>dcmpg</i> instruction pushes an <code>int</code> -<i>1</i> onto the 
operand stack, and the <i>ifge</i> instruction does not branch. Whether <code>d</code> is greater than 
<code>100.0</code> or is NaN, the <i>dcmpg</i> instruction pushes an <code>int</code> <i>1</i> onto the operand stack, and 
the <i>ifge</i> branches. If <code>d</code> is equal to <code>100.0</code>, the <i>dcmpg</i> instruction pushes an <code>int</code> <i>0</i> onto the 
operand stack, and the <i>ifge</i> branches.
<p><a name="10361"></a>
The <i>dcmpl</i> instruction achieves the same effect if the comparison is reversed:<p>
<pre><br><a name="8634"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>int greaterThan100(double d) {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	if (d &gt; 100.0) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    return 1;			
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	} else {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    return -1;			
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="8633"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="8657"></a>
becomes
<p><a name="8625"></a>
 <i>Method </i><code>int</code> <code>greaterThan100(double)<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>dload_1
</i><br><td>

<tr><td>          <i>   1 
</i><br><td>          <i>ldc2_w #4 
</i><br><td><i>// Double </i><code>100.000000
</code>
<tr><td>          <i>   4 
</i><br><td>          <i>dcmpl
</i><br><td><i>// Push </i>-<i>1 if </i><code>d</code><i> is Nan or </i><code>d</code><i> </i><<code> 100.000000</code><i>;
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// push 0 if </i><code>d</code><i> == </i><code>100.000000
</code>
<tr><td>          <i>   5 
</i><br><td>          <i>ifle 10
</i><br><td><i>// Branch on 0 or </i>-<i>1
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>iconst_1
</i><br><td>

<tr><td>          <i>   9 
</i><br><td>          <i>ireturn
</i><br><td>

<tr><td>          <i>  10 
</i><br><td>          <i>iconst_m1
</i><br><td>

<tr><td>          <i>  11 
</i><br><td>          <i>ireturn
</i><br><td>

</Table><br><br></code><p>
<a name="8658"></a>
Once again, whether the comparison fails on a non-NaN value or because it is 
passed a NaN, the <i>dcmpl</i> instruction pushes an <code>int</code> value onto the operand stack that 
causes the <i>ifle</i> to branch. If both of the <i>dcmp</i> instructions did not exist, one of the 
example methods would have had to do more work to detect NaN.
<p><a name="8556"></a>
<hr><h2>7.6	 Receiving Arguments</h2>
<a name="4344"></a>
If <em>n</em> arguments are passed to a Java instance method, they are received, by convention, 
in the local variables numbered <i>1</i> through <i>n</i> of the frame created for the new method 
invocation. The arguments are received in the order they were passed. For example:
<p><pre><br><a name="5021"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>int addTwo(int i, int j) {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return i + j;
</code><a name="4353"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="4349"></a>
compiles to
<p><a name="4360"></a>
 <i>Method </i><code>int</code> <code>addTwo(int,int)<p><Table Border="0">
<tr><td>          <i>   0
</i><br><td>          <i>iload_1
</i><br><td><i>// Push value of local 1 (</i><code>i</code><i>)
</i>
<tr><td>          <i>   1
</i><br><td>          <i>iload_2
</i><br><td><i>// Push value of local 2 (</i><code>j</code><i>)
</i>
<tr><td>          <i>   2
</i><br><td>          <i>iadd
</i><br><td><i>// Add; leave </i><code>int</code><i> result on val stack
</i>
<tr><td>          <i>   3 
</i><br><td>          <i>ireturn
</i><br><td><i>// Return </i><code>int</code><i> result
</i>
</Table><br><br></code><p>
<a name="9840"></a>
By convention, an instance method is passed a <code>reference</code> to its instance in local variable zero. The instance is accessible in Java via the <code>this</code> keyword. Code to push <code>this</code> into local variable zero must be present in the invoker of an instance method (see <a href="Compiling.doc.html#4425">Section 7.7, "Invoking Methods"</a>).<p>
<a name="9846"></a>
Class (<code>static</code>) methods do not have an instance, so for them this use of local variable zero is unnecessary. A class method starts using local variables at index zero. If the <code>addTwo</code> method was a class method, its arguments would be passed in a similar way to the first version:<p>
<pre><br><a name="5917"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>static int addTwoStatic(int i, int j) {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return i + j;
</code><a name="5919"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="5915"></a>
compiles to
<p><a name="5910"></a>
 <i>Method </i><code>int</code> <code>addTwoStatic(int,int)<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td><i>iload_0
</i>
<tr><td>          <i>   1
</i><br><td><i>iload_1
</i>
<tr><td>          <i>   2 
</i><br><td><i>iadd
</i>
<tr><td>          <i>   3 
</i><br><td><i>ireturn
</i>
</Table><br><br></code><p>
<a name="10390"></a>
The only difference is that the method arguments appear starting in local variable <i>0</i> 
rather than <i>1</i>.
<p><a name="4425"></a>
<hr><h2>7.7	 Invoking Methods</h2>
<a name="5974"></a>
The normal method invocation for a Java instance method dispatches on the runtime 
type of the object (they are virtual, in C++ terms). Such an invocation is implemented using the <i>invokevirtual</i> instruction, which takes as its argument an index to 
a constant pool entry giving the fully qualified name of the class type of the object, 
the name of the method to invoke, and that method's descriptor <a href="ClassFile.doc.html#7035">(&#167;4.3.3)</a>. To invoke 
the <code>addTwo</code> method, defined earlier as an instance method, we might write
<p><pre><br><a name="5975"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>int add12and13() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return addTwo(12, 13);
</code><a name="4398"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="25875"></a>
This compiles to 

<p><a name="25880"></a>
 <i>Method </i><code>int</code> <code>add12and13()</code><p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_0
</i><br><td><i>// Push this local 0 (</i><code>this</code><i>) onto stack
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>bipush 12
</i><br><td><i>// Push </i><code>int</code><i> constant </i><code>12</code><i> onto stack
</i>
<tr><td>          <i>   3 
</i><br><td>          <i>bipush 13
</i><br><td><i>// Push </i><code>int</code><i> constant </i><code>13</code><i> onto stack
</i>
<tr><td>          <i>   5 
</i><br><td>          <i>invokevirtual 
#4
</i><br><td><i>// Method </i><code>Example.addtwo(II)I
</code>
<tr><td>          <i>   8
</i><br><td>          <i>ireturn
</i><br><td><i>// Return </i><code>int</code><i> on top of stack; it is
</i>
<tr><td>          
<br><td>          
<br><td><i>// the </i><code>int</code><i> result of </i><code>addTwo()
</code>
</Table><br><br><p>
<a name="25876"></a>
<p>
<a name="25877"></a>
The invocation is set up by first pushing a <code>reference</code> to the current instance, <code>this</code>, onto the operand stack. The method invocation's arguments, <code>int</code> values <code>12</code> and <code>13</code>, are then pushed. When the frame for the <code>addTwo</code> method is created, the arguments passed to the method become the initial values of the new frame's local variables. That is, the <code>reference</code> for <code>this</code> and the two arguments, pushed onto the operand stack by the invoker, will become the initial values of local variables <i>0</i>, <i>1</i>, and <i>2</i> of the invoked method. <p>
<a name="5962"></a>
Finally, <code>addTwo</code> is invoked. When it returns, its <code>int</code> return value is pushed onto the operand stack of the frame of the invoker, the <code>add12and13</code> method. The return value is thus put in place to be immediately returned to the invoker of <code>add12and13</code>. <p>
<a name="10439"></a>
The return from <code>add12and13</code> is handled by the <i>ireturn</i> instruction of <code>add12and13</code>. The <i>ireturn</i> instruction takes the <code>int</code> value returned by <code>addTwo</code>, on the operand stack of the current frame, and pushes it onto the operand stack of the frame of the invoker. It then returns control to the invoker, making the invoker's frame current. The Java Virtual Machine provides distinct return instructions for many of its numeric and <code>reference</code> data types, as well as a <i>return</i> instruction for methods with no return value. The same set of return instructions is used for all varieties of method invocations.<p>
<a name="10497"></a>
The operand of the <i>invokevirtual </i>instruction (in the example, the constant pool index <i>#4</i>) is not the offset of the method in the class instance. The Java compiler does not know the internal layout of a class instance. Instead, it generates symbolic references to the methods of an instance, which are stored in the constant pool. Those constant pool items are resolved at run time to determine the actual method location. The same is true for all other Java Virtual Machine instructions that access class instances.<p>
<a name="6012"></a>
Invoking <code>addTwoStatic</code>, a class (<code>static</code>) variant of <code>addTwo</code>, is similar:<p>
<pre><br><a name="8844"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>int add12and13() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return addTwoStatic(12, 13);
</code><a name="8846"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="8842"></a>
although a different Java Virtual Machine method invocation instruction is used:
<p><a name="8786"></a>
 <i>Method </i><code>int add12and13()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>bipush 12
</i><br><td>

<tr><td>          <i>   2 
</i><br><td>          <i>bipush 13
</i><br><td>

<tr><td>          <i>   4 
</i><br><td>          <i>invokestatic #3 
</i><br><td><i>// Method </i><code>Example.addTwoStatic(II)I
</code>
<tr><td>          <i>   7 
</i><br><td>          <i>ireturn
</i><br><td>

</Table><br><br></code><p>
<a name="8784"></a>
Compiling an invocation of a class (<code>static</code>) method is very much like compiling an 
invocation of an instance method, except <code>this</code> is not passed by the invoker. The 
method arguments will thus be received beginning with local variable <i>0</i> (see <a href="Compiling.doc.html#8556">Section 
7.6, "Receiving Arguments"</a>). The <i>invokestatic</i> instruction is always used to invoke 
class methods.
<p><a name="9398"></a>
The <i>invokespecial</i> instruction must be used to invoke instance initialization (<code>&lt;init&gt;</code>) methods (see <a href="Compiling.doc.html#4089">Section 7.8, "Working with Class Instances"</a>). It is also used when invoking methods in the superclass (<code>super</code>) and when invoking <code>private</code> methods. For instance, given classes <code>Near</code> and <code>Far</code> declared as<p>
<pre><br><a name="9433"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>class Near {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>    	int it;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	public int getItNear() {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>		return getIt();
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>    	private int getIt() {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>		return it;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>    	}
</code><br><a name="9423"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br><a name="12879"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>class Far extends Near {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>    	int getItFar() {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>		return super.getItNear();
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>    	}
</code><a name="9427"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="9477"></a>
the method <code>Near.getItNear</code> (which invokes a <code>private</code> method) becomes
<p><a name="9478"></a>
 <i>Method </i><code>int</code> <code>getItNear()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_0
</i><br><td>          
<br>
<tr><td>          <i>   1 
</i><br><td>          <i>invokespecial 
#5 
</i><br><td><i>// Method </i><code>Near.getIt()I
</code>
<tr><td>          <i>   4 
</i><br><td>          <i>ireturn
</i><br><td>          
<br>
</Table><br><br></code><p>
<a name="9407"></a>
The method <code>Far.getItFar</code> (which invokes a superclass method) becomes
<p><a name="9438"></a>
 <i>Method </i><code>int</code> <code>getItFar()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_0
</i><br><td>

<tr><td>          <i>   1 
</i><br><td>          <i>invokespecial 
#4
</i><br><td><i>// Method </i><code>Near.getItNear()I
</code>
<tr><td>          <i>   4
</i><br><td>          <i>ireturn
</i><br><td>

</Table><br><br></code><p>
<pre><a name="25556"></a>&nbsp;&nbsp;&nbsp;&nbsp;<i>
</i><br></pre><a name="10459"></a>
Note that methods called using the <i>invokespecial</i> instruction always pass <code>this</code> to the 
invoked method as its first argument. As usual, it is received in local variable <i>0</i>.
<p><a name="4089"></a>
<hr><h2>7.8	 Working with Class Instances</h2>
<a name="4438"></a>
Java Virtual Machine class instances are created using the Java Virtual Machine's 
<i>new</i> instruction. Once the class instance has been created and its instance variables, 
including those of the class and all of its superclasses, have been initialized to their 
default values, an instance initialization method of the new class instance (<code>&lt;init&gt;</code>) is 
invoked. [Recall that at the level of the Java Virtual Machine, a constructor appears 
as a method with the special compiler-supplied name <code>&lt;init&gt;</code>. This special method is 
known as the instance initialization method <a href="Overview.doc.html#12174">(&#167;3.8)</a>. Multiple instance initialization 
methods, corresponding to multiple constructors, may exist for a given class.] For 
example:
<p><pre><br><a name="4445"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>Object create() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return new Object();
</code><a name="4448"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="4442"></a>
compiles to
<p><a name="7013"></a>
 <i>Method </i><code>java.lang.Object</code> <code>create()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>new #1 
</i><br><td><i>// Class java.lang.Object
</i>
<tr><td>          <i>   3 
</i><br><td>          <i>dup
</i><br><td><i>
</i>
<tr><td>          <i>   4 
</i><br><td>          <i>invokespecial 
#4 
</i><br><td><i>// Method java.lang.Object.&lt;init&gt;()V
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>areturn
</i><br><td><i>
</i>
</Table><br><br></code><p>
<a name="4630"></a>
Class instances are passed and returned (as <code>reference</code> types) very much like numeric values, although type <code>reference</code> has its own complement of instructions:<p>
<pre><br><a name="7661"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>int i;					// An instance variable
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>MyObj example() {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	MyObj o = new MyObj();
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return silly(o);
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>MyObj silly(MyObj o) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	if (o != null) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    return o;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	} else {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    return o;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="16770"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="16771"></a>
becomes
<p><a name="16899"></a>
 <i>Method </i><code>MyObj</code> <code>example()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>new #2 
</i><br><td><i>// Class MyObj
</i>
<tr><td>          <i>   3 
</i><br><td>          <i>dup
</i><br><td><i>
</i>
<tr><td>          <i>   4 
</i><br><td>          <i>invokespecial 
#5 
</i><br><td><i>// Method MyObj.&lt;init&gt;()V
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>astore_1
</i><br><td><i>
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>aload_0
</i><br><td><i>
</i>
<tr><td>          <i>   9 
</i><br><td>          <i>aload_1
</i><br><td><i>
</i>
<tr><td>          <i>  10 
</i><br><td>          <i>invokevirtual 
#4 
</i><br><td><i>
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// Method Example.silly(LMyObj;)LMyObj;
</i>
<tr><td>          <i>  13 
</i><br><td>          <i>areturn
</i><br><td><i>
</i>
</Table><br><br></code><p>
<a name="7653"></a>
 <i>Method </i><code>MyObj</code> <code>silly(MyObj)<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_1
</i><br>
<tr><td>          <i>   1 
</i><br><td>          <i>ifnull 6
</i><br>
<tr><td>          <i>   4
</i><br><td>          <i>aload_1
</i><br>
<tr><td>          <i>   5 
</i><br><td>          <i>areturn
</i><br>
<tr><td>          <i>   6 
</i><br><td>          <i>aload_1</i>
<br>
<tr><td>          <i>   7 
</i><br><td><a name="25574"></a>
<i>areturn</i><p>

</Table><br><br></code><p>
<a name="4716"></a>
The fields of a class instance (instance variables) are accessed using the <i>getfield</i> and <i>putfield</i> instructions. If <code>i</code> is an instance variable of type <code>int</code>, the methods <code>setIt</code> and <code>getIt,</code> defined as<p>
<pre><br><a name="4760"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void setIt(int value) {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	i = value;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>int getIt() {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return i;
</code><a name="13220"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="13221"></a>
become
<p><a name="13222"></a>
 <i>Method </i><code>void</code> <code>setIt(int)<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_0
</i><br><td><i>
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>iload_1
</i><br><td><i>
</i>
<tr><td>          <i>   2 
</i><br><td>          <i>putfield #4 
</i><br><td><i>// Field Example.i I
</i>
<tr><td>          <i>   5
</i><br><td>          <i>return
</i><br><td><i>
</i>
</Table><br><br></code><p>
<pre><br><a name="4753"></a>&nbsp;&nbsp;&nbsp;&nbsp;<i>Method </i><code>int</code> <code>getIt()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_0
</i><br><td><i>
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>getfield #4 
</i><br><td><i>// Field Example.i I
</i>
<tr><td>          <i>   4
</i><br><td>          <i>ireturn
</i><br><td><i>
</i>
</Table><br><br>
</code></pre><a name="4719"></a>
As with the operands of method invocation instructions, the operands of the <i>putfield</i> 
and <i>getfield</i> instructions (the constant pool index <i>#4</i>) are not the offsets of the fields 
in the class instance. The Java compiler generates symbolic references to the fields 
of an instance, which are stored in the constant pool. Those constant pool items are 
resolved at run time to determine the actual field offset.
<p><a name="4091"></a>
<hr><h2>7.9	 Arrays</h2>
<a name="4816"></a>
Java Virtual Machine arrays are also objects. Arrays are created and manipulated 
using a distinct set of instructions. The <i>newarray</i> instruction is used to create an 
array of a numeric type. The &#32;code
<p><pre><br><a name="4872"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void createBuffer() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	int buffer[];
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	int bufsz = 100;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	int value = 12;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	buffer = new int[bufsz];
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	buffer[10] = value;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	value = buffer[11];
</code><a name="4879"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="8889"></a>
might be compiled to
<p><a name="4854"></a>
 <i>Method </i><code>void</code> <code>createBuffer()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>bipush 100
</i><br><td><i>// Push bufsz
</i>
<tr><td>          <i>   2 
</i><br><td>          <i>istore_2
</i><br><td><i>// Store bufsz in local 2
</i>
<tr><td>          <i>   3 
</i><br><td>          <i>bipush 12
</i><br><td><i>// Push value
</i>
<tr><td>          <i>   5 
</i><br><td>          <i>istore_3
</i><br><td><i>// Store value in local 3
</i>
<tr><td>          <i>   6
</i><br><td>          <i>iload_2
</i><br><td><i>// Push bufsz...
</i>
<tr><td>          <i>   7
</i><br><td>          <i>newarray </i><code>int
</code><br><td><i>// ...and create new array of int
</i>
<tr><td>          <i>   9 
</i><br><td>          <i>astore_1
</i><br><td><i>// Store new array in buffer
</i>
<tr><td>          <i>  10 
</i><br><td>          <i>aload_1
</i><br><td><i>// Push buffer
</i>
<tr><td>          <i>  11 
</i><br><td>          <i>bipush 10
</i><br><td><i>// Push constant 10
</i>
<tr><td>          <i>  13 
</i><br><td>          <i>iload_3
</i><br><td><i>// Push value
</i>
<tr><td>          <i>  14 
</i><br><td>          <i>iastore
</i><br><td><i>// Store value at buffer[10]
</i>
<tr><td>          <i>  15 
</i><br><td>          <i>aload_1
</i><br><td><i>// Push buffer
</i>
<tr><td>          <i>  16 
</i><br><td>          <i>bipush 11
</i><br><td><i>// Push constant 11
</i>
<tr><td>          <i>  18 
</i><br><td>          <i>iaload
</i><br><td><i>// Push value at buffer[11]
</i>
<tr><td>          <i> &#32; 19 
</i><br><td>          <i>istore_3
</i><br><td><i>// ...and store it in value
</i>
<tr><td>          <i>  20
</i><br><td>          <i>return
</i><br><td><i>
</i>
</Table><br><br></code><p>
<a name="6189"></a>
The <i>anewarray</i> instruction is used to create a one-dimensional array of object references:<p>
<pre><br><a name="6192"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void createThreadArray() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	Thread threads[];
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	int count = 10;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	threads = new Thread[count];
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	threads[0] = new Thread();
</code><a name="6197"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="6187"></a>
becomes
<p><a name="6188"></a>
 <i>Method </i><code>void createThreadArray()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>bipush 10
</i><br><td><i>// Push 10...
</i>
<tr><td>          <i>   2 
</i><br><td>          <i>istore_2
</i><br><td><i>// ...and initialize count to that
</i>
<tr><td>          <i>   3 
</i><br><td>          <i>iload_2
</i><br><td><i>// Push count, used by anewarray
</i>
<tr><td>          <i>   4 
</i><br><td>          <i>anewarray 
class #1 
</i><br><td><i>// Create new array of class Thread
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>astore_1
</i><br><td><i>// Store new array in threads
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>aload_1
</i><br><td><i>// Load value of threads on stack
</i>
<tr><td>          <i>   9 
</i><br><td>          <i>iconst_0
</i><br><td><i>// Load 0 into stack
</i>
<tr><td>          <i>  10 
</i><br><td>          <i>new #1 
</i><br><td><i>// Create instance of class Thread
</i>
<tr><td>          <i>  13 
</i><br><td>          <i>dup
</i><br><td><i>// Make duplicate reference...
</i>
<tr><td>          <i>  14 
</i><br><td>          <i>invokespecial 
#5 
</i><br><td><i>// ...to pass to initialization method
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// Method java.lang.Thread.&lt;init&gt;()V
</i>
<tr><td>          <i>  17 
</i><br><td>          <i>aastore
</i><br><td><i>// Store new Thread in array at 0
</i>
<tr><td>          <i>  18 
</i><br><td>          <i>return
</i><br><td><i>
</i>
</Table><br><br></code><p>
<a name="5674"></a>
The<i> anewarray</i> instruction can also be used to create the first dimension of a multidimensional array. Alternatively, the <i>multianewarray</i> instruction can be used to create several dimensions at once. For example, the three-dimensional array in the following:<p>
<pre><br><a name="6235"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>int[][][] create3DArray() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	int grid[][][];
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	grid = new int[10][5][];
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return grid;
</code><a name="12919"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="12921"></a>
is created by
<p><a name="6227"></a>
 <i>Method </i><code>int</code> <code>create3DArray()[][][]<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>bipush 10
</i><br><td><i>// Push 10 (dimension one)
</i>
<tr><td>          <i>   2 
</i><br><td>          <i>iconst_5
</i><br><td><i>// Push 5 (dimension two)
</i>
<tr><td>          <i>   3 
</i><br><td>          <i>multianewarra
y #1 dim #2 
</i><br><td><i>// Class [[[I, a three
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// dimensional int array;
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// only create first two 
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// dimensions
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>astore_1
</i><br><td><i>// Store new array...
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>aload_1
</i><br><td><i>// ...then prepare to return it
</i>
<tr><td>          <i>   9 
</i><br><td>          <i>areturn
</i><br><td><i>
</i>
</Table><br><br></code><p>
<a name="5678"></a>
The first operand of the <i>multianewarray</i> instruction is the constant pool index to the 
array class type to be created. The second is the number of dimensions of that array type 
to actually create. The <i>multianewarray</i> instruction can be used to create all the dimensions of the type, as the code for <code>create3DArray</code> shows. Note that the multidimensional 
array is just an object, and so is loaded and returned by an <i>aload_1</i> and <i>areturn</i> instruction, respectively. For information about array class names, see <a href="ClassFile.doc.html#1221">&#167;4.4.1</a>.
<p><a name="6342"></a>
All arrays have associated lengths, which are accessed via the <i>arraylength</i> instruction.<p>
<a name="4095"></a>
<hr><h2>7.10	 Compiling Switches</h2>
<a name="25132"></a>
Java's <code>switch</code> statements are compiled using the <i>tableswitch</i> and <i>lookupswitch</i> 
instructions. The <i>tableswitch</i> instruction is used when the cases of the <code>switch</code> can be 
efficiently represented as indices into a table of target offsets. The <code>default</code> target of 
the <code>switch</code> is used if the value of the expression of the <code>switch</code> falls outside the range of 
valid indices. For instance,
<p><pre><br><a name="25321"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>int chooseNear(int i) {int chooseNear(int i) {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	switch (i) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    case 0: 			return 0;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    case 1: 			return 1;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    case 2: 			return 2;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    default:			return -1;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="25328"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br><br><a name="25317"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>
</code><br><a name="25318"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>
</code></pre><a name="25319"></a>
compiles to
<p><a name="4512"></a>
 <i>Method </i><code>int</code> <code>chooseNear(int)<p><Table Border="0">
<tr><td>          <i>   0
</i><br><td>          <i>iload_1
</i><br><td><i>// Load local 1 (argument i)
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>tableswitch 0 to 
2: 
</i><br><td><i>// Valid indices are 0 through 2
</i>
<tr><td>          <i>
</i><br><td>          <i>0: 28
</i><br><td><i>// If i is 0, continue at 28
</i>
<tr><td>          <i>
</i><br><td>          <i>1: 30
</i><br><td><i>// If i is 1, continue at 30
</i>
<tr><td>          <i>
</i><br><td>          <i>2: 32
</i><br><td><i>// If i is 2, continue at 32
</i>
<tr><td>          <i>
</i><br><td>          <i>default:34
</i><br><td><i>// Otherwise, continue at 34
</i>
<tr><td>          <i>  28 
</i><br><td>          <i>iconst_0
</i><br><td><i>// i was 0; push int 0...
</i>
<tr><td>          <i>  29 
</i><br><td>          <i>ireturn
</i><br><td><i>// ...and return it
</i>
<tr><td>          <i>  30 
</i><br><td>          <i>iconst_1
</i><br><td><i>// i was 1; push int 1...
</i>
<tr><td>          <i>  31 
</i><br><td>          <i>ireturn
</i><br><td><i>// ...and return it
</i>
<tr><td>          <i>  32 
</i><br><td>          <i>iconst_2
</i><br><td><i>// i was 2; push int 2...
</i>
<tr><td>          <i>  33 
</i><br><td>          <i>ireturn
</i><br><td><i>// ...and return it
</i>
<tr><td>          <i>  34 
</i><br><td>          <i>iconst_m1
</i><br><td><i>// otherwise push int -1...
</i>
<tr><td>          <i>  35 
</i><br><td>          <i>ireturn
</i><br><td><i>// ...and return it
</i>
</Table><br><br></code><p>
<a name="7459"></a>
The Java Virtual Machine's <i>tableswitch</i> and <i>lookupswitch</i> instructions only operate on <code>int</code> data. Because operations on <code>byte</code>, <code>char</code>, or <code>short</code> values are internally promoted to <code>int</code>, a <code>switch</code> whose expression evaluates to one of those types is compiled as though it evaluated to type <code>int</code>. If the <code>chooseNear</code> method had been written using type <code>short</code>, the same Java Virtual Machine instructions would have been generated as when using type <code>int</code>. Other numeric types must be narrowed to type <code>int</code> for use in a <code>switch</code>.<p>
<a name="7490"></a>
Where the cases of the <code>switch</code> are sparse, the table representation of the <i>tableswitch</i> instruction becomes inefficient in terms of space. The <i>lookupswitch</i> instruction may be used instead. The <i>lookupswitch</i> instruction pairs <code>int</code> keys (the values of the <code>case</code> labels) with target offsets in a table. When a <i>lookupswitch</i> instruction is executed, the value of the expression of the <code>switch</code> is compared against the keys in the table. If one of the keys matches the value of the expression, execution continues at the associated target offset. If no key matches, execution continues at the <code>default</code> target. For instance, the compiled code for<p>
<a name="7595"></a>
 <code>int chooseFar(int i) {<p><Table Border="0">
<tr><td>          <code>
</code><br><td>          <i>switch (i) {
</i><br><td><i>
</i>
<tr><td>          <code>
</code><br><td>          <i>    case -100:
</i><br><td><i>return -1;
</i>
<tr><td>          <code>
</code><br><td>          <i>    case 0:
</i><br><td><i>return 0;
</i>
<tr><td>          <code>
</code><br><td>          <i>    case 100:
</i><br><td><i>return 1;
</i>
<tr><td>          <code>
</code><br><td>          <i>    default:
</i><br><td><i>return -1;
</i>
<tr><td>          <code>
</code><br><td><a name="26062"></a>
<code>}</code><p>
<td>

<tr><td>          <code>}
</code><br><td><a name="26072"></a>
<code></code><p>
<td>

</Table><br><br></code><p>
<a name="7521"></a>
looks just like the code for <code>chooseNear</code>, except for the use of the <i>lookupswitch</i> 
instruction:
<p><a name="26196"></a>
 <i>Method </i><code>int</code> <code>chooseFar(int)</code><i> </i><p><Table Border="0">
<tr><td>          <i>0 
</i><br><td>          <i>iload_1
</i><br><td><i>
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>lookupswitch 3: 
</i><br><td><i>
</i>
<tr><td>          <i>
</i><br><td>          <i> 
</i><br><td><i>-100: 36
</i>
<tr><td>          <i>
</i><br><td>          <i> 
</i><br><td><i>0: 38
</i>
<tr><td>          <i>
</i><br><td>          <i> 
</i><br><td><i>100: 40
</i>
<tr><td>          
<br><td>          <i> 
</i><br><td><i>default:42
</i>
<tr><td>          <i>  36 
</i><br><td>          <i>iconst_m1
</i><br><td><i>
</i>
<tr><td>          <i>  37 
</i><br><td>          <i>ireturn
</i><br><td><i>
</i>
<tr><td>          <i>  38 
</i><br><td>          <i>iconst_0
</i><br><td><i>
</i>
<tr><td>          <i>  39 
</i><br><td>          <i>ireturn
</i><br><td><i>
</i>
<tr><td>          <i>  40 
</i><br><td>          <i>iconst_1
</i><br><td><i>
</i>
<tr><td>          <i>  41
</i><br><td>          <i>ireturn
</i><br><td><i>
</i>
<tr><td>          <i>  42 
</i><br><td>          <i>const_m1
</i><br><td><i>
</i>
<tr><td>          <i>  43 
</i><br><td>          <i>ireturn
</i><br><td><i>
</i>
</Table><br><br>T<p>
<a name="26282"></a>
The Java Virtual Machine specifies that the table of the <i>lookupswitch</i> instruction must be sorted by key so that implementations may use searches more efficient than a linear scan. Even so, the <i>lookupswitch</i> instruction must search its keys for a match rather than simply perform a bounds check and index into a table like <i>tableswitch</i>. Thus, a <i>tableswitch</i> instruction is probably more efficient than a <i>lookupswitch</i> where space considerations permit a choice. <p>
<a name="9342"></a>
<hr><h2>7.11	 Operations on the Operand Stack</h2>
<a name="9512"></a>
The Java Virtual Machine has a large complement of instructions that manipulate 
the contents of the operand stack as untyped words or pairs of untyped words. These 
are useful because of the Java Virtual Machine's reliance on deft manipulation of its 
operand stack. For instance:
<p><pre><br><a name="9346"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>public long nextIndex() { 
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	return index++;
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><a name="9347"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>private long index = 0;
</code><br></pre><a name="9556"></a>
is compiled to
<p><a name="9350"></a>
 <i>Method </i><code>long nextIndex()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_0
</i><br><td><i>// Write this onto operand stack
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>dup
</i><br><td><i>// Make a copy of it
</i>
<tr><td>          <i>   2 
</i><br><td>          <i>getfield #4 
</i><br><td><i>// One of the copies of this is consumed
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// loading long field index onto stack,
</i>
<tr><td>          
<br><td>          <i>
</i><br><td><i>// above the original this
</i>
<tr><td>          <i> &#32; &#32; &#32;5 
</i><br><td>          <i>dup2_x1
</i><br><td><i>// The long on top of the stack is 
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// inserted into the stack below the 
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// original this
</i>
<tr><td>          <i>   6 
</i><br><td>          <i>lconst_1
</i><br><td><i>// A long 1 is loaded onto the stack
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>ladd
</i><br><td><i>// The index value is incremented
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>putfield #4 
</i><br><td><i>// and the result stored back in the field
</i>
<tr><td>          <i>  11 
</i><br><td>          <i>lreturn
</i><br><td><i>// The original value of index is left on
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// top of the stack, ready to be returned
</i>
</Table><br><br></code><p>
<a name="10586"></a>
Note that the Java Virtual Machine never allows its operand stack manipulation 
instructions to modify or move the words of its two-word data types individually.
<p><a name="9934"></a>
<hr><h2>7.12	 Throwing and Handling Exceptions </h2>
<a name="9236"></a>
Exceptions are thrown from Java programs using the <code>throw</code> keyword. Its compilation 
is simple:
<p><pre><br><a name="9237"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void cantBeZero(int i) throws TestExc {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	if (i == 0) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    throw new TestExc();
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="9241"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="9243"></a>
becomes
<p><a name="9244"></a>
 <i>Method </i><code>void</code> <code>cantBeZero(int)<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>iload_1
</i><br><td><i>// Load argument 1 (i) onto stack
</i>
<tr><td>          <i>   1
</i><br><td>          <i>ifne 12
</i><br><td><i>// If i==0, allocate instance and throw
</i>
<tr><td>          <i>   4
</i><br><td>          <i>new #1 
</i><br><td><i>// Create instance of TestExc
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>dup
</i><br><td><i>// One reference goes to the constructor
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>invokespecial 
#7 
</i><br><td><i>// Method TestExc.&lt;init&gt;()V
</i>
<tr><td>          <i>  11 
</i><br><td>          <i>athrow
</i><br><td><i>// Second reference is thrown
</i>
<tr><td>          <i>  12 
</i><br><td>          <i>return
</i><br><td><i>// Never get here if we threw TestExc
</i>
</Table><br><br></code><p>
<a name="7996"></a>
Compilation of Java's <code>try</code>-<code>catch</code> is straightforward. For example:<p>
<pre><br><a name="25121"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void catchOne() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	try {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    tryItOut();
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	} catch (TestExc e) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    handleExc(e);
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><br><a name="25119"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code></pre><a name="8011"></a>
is compiled as
<p><a name="8910"></a>
 <i>Method </i><code>void</code> <code>catchOne()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_0
</i><br><td><i>// Beginning of </i><code>try</code><i> block
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>invokevirtual 
#6 
</i><br><td><i>// Method </i><code>Example.tryItOut()V
</code>
<tr><td>          <i>   4 
</i><br><td>          <i>return
</i><br><td><i>// End of </i><code>try</code><i> block; normal return
</i>
<tr><td>          <i>   5 
</i><br><td>          <i>astore_1
</i><br><td><i>// Store thrown value in local variable 1
</i>
<tr><td>          <i>   6 
</i><br><td>          <i>aload_0
</i><br><td><i>// Load </i><code>this</code><i> onto stack
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>aload_1
</i><br><td><i>// Load thrown value onto stack
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>invokevirtual 
#5 
</i><br><td><i>// Invoke handler method: 
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// </i><code>Example.handleExc(LTestExc;)V
</code>
<tr><td>          <i>  11 
</i><br><td>          <i>return
</i><br><td><i>// Return after handling </i><code>TestExc
</code>
</Table><br><br></code><p>
<a name="8919"></a>
 <i>Exception table:<p><Table Border="0">
<tr><td><a name="26420"></a>
<i>From </i>
<td><a name="26422"></a>
<i>To </i>
<td><a name="26424"></a>
<i>Target </i>
<td><a name="26426"></a>
<i>Type</i>

<tr><td><a name="26428"></a>
<i>0     </i>
<td><a name="26430"></a>
<i>4     </i>
<td><a name="26432"></a>
<i>5 </i>
<td><a name="26434"></a>
<i>Class </i><code>TestExc</code>

</Table><br><br></i><p>
<a name="19737"></a>
Looking more closely, the <code>try</code> block is compiled just as it would be if the <code>try</code> were not 
present:
<p><a name="8023"></a>
 <i>Method </i><code>void</code> <code>catchOne()<p><Table Border="0">
<tr><td>          <i>   0
</i><br><td>          <i>aload_0
</i><br><td><i>// Beginning of </i><code>try</code><i> block
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>invokevirtual 
#4 
</i><br><td><i>// Method </i><code>Example.tryItOut()V
</code>
<tr><td>          <i>   4 
</i><br><td>          <i>return
</i><br><td><i>// End of </i><code>try</code><i> block; normal return
</i>
</Table><br><br></code><p>
<a name="8016"></a>
If no exception is thrown during the execution of the <code>try</code> block, it behaves as though 
the <code>try</code> were not there: <code>tryItOut</code> is invoked and <code>catchOne</code> returns. 
<p><a name="8894"></a>
Following the <code>try</code> block is the Java Virtual Machine code that implements the single <code>catch</code> clause:<p><Table Border="0">
<tr><td>          <i>   5 
</i><br><td>          <i>astore_1
</i><br><td><i>// Store thrown value in local variable 1
</i>
<tr><td>          <i>   6 
</i><br><td>          <i>aload_0
</i><br><td><i>// Load </i><code>this</code><i> onto stack 
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>aload_1
</i><br><td><i>// Load thrown value onto stack
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>invokevirtual 
#5 
</i><br><td><i>// Invoke handler method: 
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// </i><code>Example.handleExc(LTestExc;)V
</code>
<tr><td>          <i>  11 
</i><br><td>          <i>return
</i><br><td><i>// Return after handling </i><code>TestExc
</code>
</Table><br><br><p>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;<i>Exception table: </i><p>
<Table Border="0">
<tr><td><a name="26559"></a>
<i>From </i>
&nbsp;<td><a name="26561"></a>
<i>To </i>
&nbsp;<td><a name="26563"></a>
<i>Target </i>
&nbsp;<td><a name="26565"></a>
<i>Type</i>
&nbsp;
<tr><td><a name="26567"></a>
<i>0     </i>
&nbsp;<td><a name="26569"></a>
<i>4     </i>
&nbsp;<td><a name="26571"></a>
<i>5 </i>
&nbsp;<td><a name="26573"></a>
<i>Class </i><code>TestExc</code>
&nbsp;
</Table>
<i>
</i><br><a name="26592"></a>&nbsp;&nbsp;&nbsp;&nbsp;The invocation of <code>handleExc</code>, the contents of the <code>catch</code> clause, is also compiled like a 
normal method invocation. However, the presence of a <code>catch</code> clause causes the compiler to generate an exception table entry. The exception table for the <code>catchOne</code> method 
has one entry corresponding to the one argument (an instance of class <code>TestExc</code>) that the 
<code>catch</code> clause of <code>catchOne</code> can handle. If some value that is an instance of <code>TestExc</code> is 
thrown during execution of the instructions between in-dices <i>0</i> and <i>4</i> (inclusive) in 
<code>catchOne</code>, control is transferred to the Java Virtual Machine code at index <i>5</i>, which 
implements the block of the <code>catch</code> clause. If the value that is thrown is not an instance 
of <code>TestExc</code>, the <code>catch</code> clause of <code>catchOne</code> cannot handle it. Instead, the value is 
rethrown to the invoker of <code>catchOne</code>.
</pre><a name="8030"></a>
A <code>try</code> may have multiple <code>catch</code> clauses:<p>
<pre><br><a name="25103"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void catchTwo() {void catchTwo() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	try {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    tryItOut();
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	} catch (TestExc1 e) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    handleExc(e);
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	} catch (TestExc2 e) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    handleExc(e);
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code>&nbsp;&nbsp;&nbsp;&nbsp;
</pre><a name="8096"></a>
Multiple <code>catch</code> clauses of a given <code>try</code> statement are compiled by simply appending the 
Java Virtual Machine code for each <code>catch</code> clause one after the other, and adding 
entries to the exception table:
<p><a name="9958"></a>
 <i>Method </i><code>void catchTwo()}<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_0
</i><br><td><i>// Begin </i><code>try</code><i> block
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>invokevirtual 
#5 
</i><br><td><i>// Method </i><code>Example.tryItOut()V
</code>
<tr><td>          <i>   4 
</i><br><td>          <i>return
</i><br><td><i>// End of </i><code>try</code><i> block; normal return
</i>
<tr><td>          <i>   5 
</i><br><td>          <i>astore_1
</i><br><td><i>// Beginning of handler for </i><code>TestExc1</code><i>;
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// Store thrown value in local variable 1
</i>
<tr><td>          <i>   6 
</i><br><td>          <i>aload_0
</i><br><td><i>// Load </i><code>this</code><i> onto stack
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>aload_1
</i><br><td><i>// Load thrown value onto stack
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>invokevirtual 
#7 
</i><br><td><i>// Invoke handler method:
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// </i><code>Example.handleExc(LTestExc1;)V
</code>
<tr><td>          <i>  11 
</i><br><td>          <i>return
</i><br><td><i>// Return after handling </i><code>TestExc1
</code>
<tr><td>          <i>  12 
</i><br><td>          <i>astore_1
</i><br><td><i>// Beginning of handler for </i><code>TestExc2</code><i>;
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// Store thrown value in local variable 1
</i>
<tr><td>          <i>  13 
</i><br><td>          <i>aload_0
</i><br><td><i>// Load </i><code>this</code><i> onto stack
</i>
<tr><td>          <i>  14 
</i><br><td>          <i>aload_1
</i><br><td><i>// Load thrown value onto stack
</i>
<tr><td>          <i>  15 
</i><br><td>          <i>invokevirtual 
#7
</i><br><td><i>// Invoke handler method:
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// </i><code>Example.handleExc(LTestExc2;)V
</code>
<tr><td>          <i>  18 
</i><br><td>          <i>return
</i><br><td><i>// Return after handling </i><code>TestExc2
</code>
</Table><br><br></code><p>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;<i>Exception table:<p>

<Table Border="0">
<tr>
<td>From  </td><td>    To      </td>
<td>          Target 
<td>          Type

<tr><td><a name="25082"></a>
<i>0     </i>
<td>          <i>4     
</i><br><td>          <i>5   
</i><br><td>          <i>Class </i><code>TestExc1
</code><br>
<tr><td><a name="25090"></a>
<i>0     </i>
<td>          <i>4    
</i><br><td>          <i>12   
</i><br><td>          <i>Class </i><code>TestExc2
</code><br>
</Table><br><br>
</i></pre><a name="6443"></a>
If during the execution of the <code>try</code> clause (between indices <i>0</i> and <i>4</i>) a value is thrown 
that matches the parameter of one or more of the <code>catch</code> blocks (the value is an 
instance of one or more of the parameters), the first (leftmost) such <code>catch</code> clause is 
selected. Control is transferred to the Java Virtual Machine code for the block of that 
<code>catch</code> clause. If the value thrown does not match the parameter of any of the <code>catch</code> 
clauses of <code>catchTwo</code>, the Java Virtual Machine rethrows the value without invoking 
code in any <code>catch</code> clause of <code>catchTwo</code>.
<p><a name="8134"></a>
Nested <code>try</code>-<code>catch</code> statements are compiled very much like a <code>try</code> statement with multiple <code>catch</code> clauses:<p>
<pre><br><a name="8154"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void nestedCatch() {
</code><br><a name="24547"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void nestedCatch() {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	try {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    try {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	        tryItOut();
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    } catch (TestExc1 e) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>			handleExc1(e);
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    }
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	} catch (TestExc2 e) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    handleExc2(e);
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="24557"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="9213"></a>
becomes
<p><a name="9171"></a>
 <i>Method </i><code>void nestedCatch()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_0
</i><br><td><i>// Begin </i><code>try</code><i> block
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>invokevirtual 
#8 
</i><br><td><i>// Method </i><code>Example.tryItOut()V
</code>
<tr><td>          <i>   4 
</i><br><td>          <i>return
</i><br><td><i>// End of </i><code>try</code><i> block; normal return
</i>
<tr><td>          <i>   5 
</i><br><td>          <i>astore_1
</i><br><td><i>// Beginning of handler for </i><code>TestExc1</code><i>;
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// Store thrown value in local variable 1
</i>
<tr><td>          <i>   6 
</i><br><td>          <i>aload_0
</i><br><td><i>// Load </i><code>this</code><i> onto stack
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>aload_1
</i><br><td><i>// Load thrown value onto stack
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>invokevirtual 
#7 
</i><br><td><i>// Invoke handler method: 
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// </i><code>Example.handleExc1(LTestExc1;)V
</code>
<tr><td>          <i>  11 
</i><br><td>          <i>return
</i><br><td><i>// Return after handling </i><code>TestExc1
</code>
<tr><td>          <i>  12 
</i><br><td>          <i>astore_1
</i><br><td><i>// Beginning of handler for </i><code>TestExc2</code><i>;
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// Store thrown value in local variable 1
</i>
<tr><td>          <i>  13 
</i><br><td>          <i>aload_0
</i><br><td><i>// Load </i><code>this</code><i> onto stack
</i>
<tr><td>          <i>  14 
</i><br><td>          <i>aload_1
</i><br><td><i>// Load thrown value onto stack
</i>
<tr><td>          <i>  15 
</i><br><td>          <i>invokevirtual 
#6 
</i><br><td><i>// Invoke handler method:
</i>
<tr><td>          <i>
</i><br><td>          <i>
</i><br><td><i>// </i><code>Example.handleExc2(LTestExc2;)V
</code>
<tr><td>          <i>  18 
</i><br><td>          <i>return
</i><br><td><i>// Return after handling </i><code>TestExc2
</code>
</Table><br><br></code><p>
<a name="10782"></a>
 <i>Exception table:<p><Table Border="0">
<tr><td>          <i>From 
</i><br><td>          <i>To 
</i><br><td>          <i>Target 
</i><br><td>          <i>Type
</i><br>
<tr><td>          <i>0     
</i><br><td>          <i>4     
</i><br><td>          <i>5 
</i><br><td>          <i>Class </i><code>TestExc1
</code><br>
<tr><td>          <i>0    
</i><br><td>          <i>12    
</i><br><td>          <i>12 
</i><br><td>          <i>Class </i><code>TestExc2
</code><br>
</Table><br><br></i><p>
<a name="8184"></a>
The nesting of <code>catch</code> clauses is represented only in the exception table. When an 
exception is thrown, the innermost catch clause that contains the site of the exception and with a matching parameter is selected to handle it. For instance, if the invocation of <code>tryItOut</code> (at index <i>1</i>) threw an instance of <code>TestExc1</code>, it would be handled by 
the <code>catch</code> clause that invokes <code>handleExc1</code>. This is so even though the exception occurs 
within the bounds of the outer <code>catch</code> clause (catching <code>TestExc2</code>), and even though that 
outer <code>catch</code> clause might otherwise have been able to handle the thrown value.
<p><a name="13784"></a>
As a subtle point, note that the range of a <code>catch</code> clause is inclusive on the "from" end and exclusive on the "to" end (see <a href="ClassFile.doc.html#1546">&#167;4.7.4</a>). Thus, the exception table entry for the <code>catch</code> clause catching <code>TestExc1</code> does not cover the <i>return</i> instruction at offset <i>4</i>. However, the exception table entry for the <code>catch</code> clause catching <code>TestExc2</code> does cover the <i>return</i> instruction at offset <i>11</i>. Return instructions within nested <code>catch</code> clauses are included in the range of instructions covered by nesting <code>catch</code> clauses.<p>
<a name="13789"></a>
<hr><h2>7.13	 Compiling finally</h2>
<a name="23986"></a>
Compilation of a <code>try</code>-<code>finally</code> statement is similar to that of <code>try-catch</code>. Prior to transferring control outside the <code>try</code> statement, whether that transfer is normal or abrupt, 
because an exception has been thrown, the <code>finally</code> clause must first be executed. For a 
simple example:
<p><a name="24012"></a>
 <code>void tryFinally() {<p><Table Border="0">
<tr><td>          <code>
</code><br><td>          <code>try {
</code><br>
<tr><td>          <code>
</code><br><td>          <code>    tryItOut();
</code><br>
<tr><td>          <code>
</code><br><td>          <code>} finally {
</code><br>
<tr><td>          <code>
</code><br><td>          <code>    wrapItUp();
</code><br>
<tr><td>          <code>
</code><br><td>          <code>}
</code><br>
<tr><td>          <code>}
</code><br><td>          
<br>
</Table><br><br></code><p>
<a name="24013"></a>
the compiled code is
<p><a name="8363"></a>
 <i>Method </i><code>void tryFinally()<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_0
</i><br><td><i>// Beginning of </i><code>try</code><i> block
</i>
<tr><td>          <i>   1
</i><br><td>          <i>invokevirtual 
#6 
</i><br><td><i>// Method </i><code>Example.tryItOut()V
</code>
<tr><td>          <i>   4 
</i><br><td>          <i>jsr 14
</i><br><td><i>// Call </i><code>finally</code><i> block
</i>
<tr><td>          <i>   7 
</i><br><td>          <i>return
</i><br><td><i>// End of </i><code>try</code><i> block
</i>
<tr><td>          <i>   8 
</i><br><td>          <i>astore_1
</i><br><td><i>// Beginning of handler for any throw
</i>
<tr><td>          <i>   9 
</i><br><td>          <i>jsr 14
</i><br><td><i>// Call </i><code>finally</code><i> block
</i>
<tr><td>          <i>  12 
</i><br><td>          <i>aload_1
</i><br><td><i>// Push thrown value,
</i>
<tr><td>          <i>  13 
</i><br><td>          <i>athrow
</i><br><td><i>// and rethrow the value to the invoker
</i>
<tr><td>          <i>  14 
</i><br><td>          <i>astore_2
</i><br><td><i>// Beginning of </i><code>finally</code><i> block
</i>
<tr><td>          <i>  15 
</i><br><td>          <i>aload_0
</i><br><td><i>// Push </i><code>this</code><i> onto stack
</i>
<tr><td>          <i>  16 
</i><br><td>          <i>invokevirtual 
#5 
</i><br><td><i>// Method </i><code>Example.wrapItUp()V
</code>
<tr><td>          <i>  19 
</i><br><td>          <i>ret 2
</i><br><td><i>// Return from </i><code>finally</code><i> block
</i>
</Table><br><br></code><p>
<a name="8360"></a>
 <i>Exception table:<p><Table Border="0">
<tr><td>          <i>From 
</i><br><td>          <i>To 
</i><br><td>          <i>Target 
</i><br><td>          <i>Type
</i><br>
<tr><td>          <i>0    
</i><br><td>          <i>4    
</i><br><td>          <i>8   
</i><br><td>          <i>any
</i><br>
</Table><br><br></i><p>
<a name="8345"></a>
There are four ways for control to pass outside of the <code>try</code> statement: by falling 
through the bottom of that block, by returning, by executing a <code>break</code> or <code>continue</code> statement, or by raising an exception. If <code>tryItOut</code> returns without raising an exception, 
control is transferred to the <code>finally</code> block using a <i>jsr</i> instruction. The <i>jsr 14 </i>instruction at index <i>4</i> makes a "subroutine call" to the code for the <code>finally</code> block at index <i>14</i> 
(the <code>finally</code> block is compiled as an embedded subroutine). When the <code>finally</code> block 
completes, the <i>ret 2</i> instruction returns control to the instruction following the <i>jsr</i> 
instruction at index <i>4</i>. 
<p><a name="9060"></a>
In more detail, the subroutine call works as follows: The <i>jsr</i> instruction pushes the address of the following instruction (<i>return</i> at index <i>7</i>) onto the operand stack before jumping. The <i>astore_2</i> instruction that is the jump target stores the address on the operand stack into local variable <i>2</i>. The code for the <code>finally</code> block (in this case the <i>aload_0</i> and <i>invokevirtual</i> instructions) is run. Assuming execution of that code completes normally, the <i>ret</i> instruction retrieves the address from local variable <i>2</i> and resumes execution at that address. The <i>return</i> instruction is executed, and <code>tryFinally</code> returns normally.<p>
<a name="9071"></a>
A <code>try</code> statement with a <code>finally</code> clause is compiled to have a special exception handler, one that can handle any exception thrown within the <code>try</code> statement. If <code>tryItOut</code> throws an exception, the exception table for <code>tryFinally</code> is searched for an appropriate exception handler. The special handler is found, causing execution to continue at index <i>8</i>. The <i>astore_1</i> instruction at index <i>8</i> stores the thrown value into local variable <i>1</i>. The following <i>jsr</i> instruction does a subroutine call to the code for the <code>finally</code> block. Assuming that code returns normally, the <i>aload_1</i> instruction at index <i>12</i> pushes the thrown value back onto the operand stack, and the following <i>athrow</i> instruction rethrows the value.<p>
<a name="9089"></a>
Compiling a <code>try</code> statement with both a <code>catch</code> clause and a <code>finally</code> clause is more complex:<p>
<pre>
<code>void tryCatchFinally() {

   <code>try {</code>

   <code>    tryItOut();</code>

   <code>} catch (TestExc e) {</code>

   <code>    handleExc(e);</code>

   <code>} finally {</code>

   <code>    wrapItUp();</code>

   <code>}</code>

<code>}</code>
<pre>

<br><br></code><p>
<a name="9111"></a>
becomes
<p><a name="25718"></a>
 <i>Method </i><code>void</code> <code>tryCatchFinally()<p>
<Table Border="0">
<tr><td>          <i>   0 
</i><br>&nbsp;<td>          <i>aload_0
</i><br>&nbsp;<td><i>// Beginning of </i><code>try</code><i> block
</i>&nbsp;
<tr><td>          <i>   1 
</i><br>&nbsp;<td>          <i>invokevirtual 
#4 
</i><br>&nbsp;<td><i>// Method </i><code>Example.tryItOut()V
</code>&nbsp;
<tr><td>          <i>   4 
</i><br>&nbsp;<td>          <i>goto 16
</i><br>&nbsp;<td><i>// Jump to </i><code>finally</code><i> block
</i>&nbsp;
<tr><td>          <i>   7 
</i><br>&nbsp;<td>          <i>astore_3
</i><br>&nbsp;<td><i>// Beginning of handler for </i><code>TestExc</code>;
&nbsp;
<tr><td>          <i>
</i><br>&nbsp;<td>          <i>
</i><br>&nbsp;<td><i>// Store thrown value in local variable 3
</i>&nbsp;
<tr><td>          <i>   8 
</i><br>&nbsp;<td>          <i>aload_0
</i><br>&nbsp;<td><i>// Push </i><code>this</code><i> onto stack
</i>&nbsp;
<tr><td>          <i>   9 
</i><br>&nbsp;<td>          <i>aload_3
</i><br>&nbsp;<td><i>// Push thrown value onto stack
</i>&nbsp;
<tr><td>          <i>  10 
</i><br>&nbsp;<td>          <i>invokevirtual 
#6 
</i><br>&nbsp;<td><i>// Invoke handler method:
</i>&nbsp;
<tr><td>          <i>
</i><br>&nbsp;<td>          <i>
</i><br>&nbsp;<td><i>// </i><code>Example.handleExc(LTestExc;)V
</code>&nbsp;
<tr><td>          <i>  13 
</i><br>&nbsp;<td>          <i>goto 16
</i><br>&nbsp;<td><i>// Huh???</i><a href="#25650"><sup>1</sup></a>
&nbsp;
<tr><td>          <i>  16 
</i><br>&nbsp;<td>          <i>jsr 26
</i><br>&nbsp;<td><i>// Call </i><code>finally</code><i> block
</i>&nbsp;
<tr><td>          <i>  19 
</i><br>&nbsp;<td>          <i>return
</i><br>&nbsp;<td><i>// Return after handling </i><code>TestExc
</code>&nbsp;
<tr><td>          <i>  20 
</i><br>&nbsp;<td>          <i>astore_1
</i><br>&nbsp;<td><i>// Beginning of handler for exceptions
</i>&nbsp;
<tr><td>          
<br>&nbsp;<td>          
<br>&nbsp;<td><i>// other than </i><code>TestExc</code><i>, or exceptions
</i>&nbsp;
<tr><td>          <i>
</i><br>&nbsp;<td>          <i>
</i><br>&nbsp;<td><i>// thrown while handling </i><code>TestExc
</code>&nbsp;
<tr><td>          <i>  21 
</i><br>&nbsp;<td>          <i>jsr 26
</i><br>&nbsp;<td><i>// Call </i><code>finally</code><i> block
</i>&nbsp;
<tr><td>          <i>  24 
</i><br>&nbsp;<td>          <i>aload_1
</i><br>&nbsp;<td><i>// Push thrown value,
</i>&nbsp;
<tr><td>          <i>  25 
</i><br>&nbsp;<td>          <i>athrow
</i><br>&nbsp;<td><i>// and rethrow the value to the invoker
</i>&nbsp;
<tr><td>          <i>  26 
</i><br>&nbsp;<td>          <i>astore_2
</i><br>&nbsp;<td><i>// Beginning of </i><code>finally</code><i> block
</i>&nbsp;
<tr><td>          <i>  27 
</i><br>&nbsp;<td>          <i>aload_0
</i><br>&nbsp;<td><i>// Push </i><code>this</code><i> onto stack
</i>&nbsp;
<tr><td>          <i>  28 
</i><br>&nbsp;<td>          <i>invokevirtual 
#5 
</i><br>&nbsp;<td><i>// Method </i><code>Example.wrapItUp()V
</code>&nbsp;
</Table>
<p><Table Border="0">
<tr><td>          <i>  31 
</i><br><td>          <i>ret 2
</i><br><td><i>// Return from </i><code>finally</code><i> block
</i>
</Table><br><br></code><p>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;<i>
</i>&nbsp;&nbsp;&nbsp;&nbsp;<i>Exception table:<p><Table Border="0">
<tr><td><a name="26667"></a>
<i>From </i>
<td><a name="26669"></a>
<i>To </i>
<td><a name="26671"></a>
<i>Target </i>
<td><a name="26673"></a>
<i>Type</i>

<tr><td><a name="26675"></a>
<i>0     </i>
<td><a name="26677"></a>
<i>4     </i>
<td><a name="26679"></a>
<i>7 </i>
<td><a name="26681"></a>
<i>Class </i><code>TestExc</code>

<tr><td><a name="26683"></a>
<i>0   </i>
<td><a name="26685"></a>
<i>16    </i>
<td><a name="26687"></a>
<i>20   </i>
<td><a name="26689"></a>
<i>any</i>

</Table><br><br>
</i>&nbsp;&nbsp;&nbsp;&nbsp;<i>
</i></pre><a name="9112"></a>
If the <code>try</code> statement completes normally, the <i>goto</i> instruction at index <i>4</i> jumps to the subroutine call for the <code>finally</code> block at index <i>16</i>. The <code>finally</code> block at index <i>26</i> is executed, control returns to the <i>return</i> instruction at index <i>19</i>, and <code>tryCatchFinally</code> returns normally.<p>
<a name="9220"></a>
If <code>tryItOut</code> throws an instance of <code>TestExc</code>, the first (innermost) applicable exception handler in the exception table is chosen to handle the exception. The code for that exception handler, beginning at index 7, passes the thrown value to <code>handleExc</code>, and on its return makes the same subroutine call to the <code>finally</code> block at index <i>26</i> as in the normal case. If an exception is not thrown by <code>handleExc</code>, <code>tryCatchFinally</code> returns normally.<p>
<a name="9221"></a>
If <code>tryItOut</code> throws a value that is not an instance of <code>TestExc</code>, or if <code>handleExc</code> itself throws an exception, the condition is handled by the second entry in the exception table, which handles any value thrown between indices <i>0</i> and <i>16</i>. That exception handler transfers control to index <i>20</i>, where the thrown value is first stored in local variable <i>1</i>. The code for the <code>finally</code> block at index <i>26</i> is called as a subroutine. If it returns, the thrown value is retrieved from local variable <i>1</i> and rethrown using the <i>athrow</i> instruction. If a new value is thrown during execution of the <code>finally</code> clause, the <code>finally</code> clause aborts and <code>tryCatchFinally</code> returns abnormally, throwing the new value to its invoker.<p>
<a name="6530"></a>
<hr><h2>7.14	 Synchronization</h2>
<a name="6531"></a>
The Java Virtual Machine provides explicit support for synchronization through its 
<i>monitorenter</i> and <i>monitorexit</i> instructions. For Java, however, perhaps the most 
common form of synchronization is the <code>synchronized</code> method. 
<p><a name="13807"></a>
A <code>synchronized</code> method is not normally implemented using <i>monitorenter</i> and <i>monitorexit</i>. Rather, it is simply distinguished in the constant pool by the <code>ACC_SYNCHRONIZED</code> flag, which is checked by the method invocation instructions. When invoking a method for which <code>ACC_SYNCHRONIZED</code> is set, the current thread acquires a monitor, invokes the method itself, and releases the monitor whether the method invocation completes normally or abruptly. During the time the executing thread owns the monitor, no other thread may acquire it. If an exception is thrown during invocation of the <code>synchronized</code> method, and the <code>synchronized</code> method does not handle the exception, the monitor for the method is automatically released before the exception is rethrown out of the <code>synchronized</code> method.<p>
<a name="22505"></a>
The <i>monitorenter</i> and <i>monitorexit</i> instructions exist to support Java's <code>synchronized</code> statements. A <code>synchronized</code> statement acquires a monitor on behalf of the executing thread, executes the body of the statement, then releases the monitor:<p>
<pre><br><a name="22506"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>void onlyMe(Foo f) {
</code></pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;<code>	synchronized(f) {
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	    doSomething();
</code>&nbsp;&nbsp;&nbsp;&nbsp;<code>	}
</code><a name="22510"></a>&nbsp;&nbsp;&nbsp;&nbsp;<code>}
</code><br></pre><a name="22946"></a>
Compilation of synchronized statements is straightforward:
<p><a name="23949"></a>
 <i>Method </i><code>void onlyMe(Foo)<p><Table Border="0">
<tr><td>          <i>   0 
</i><br><td>          <i>aload_1
</i><br><td><i>// Load </i><code>f</code><i> onto operand stack
</i>
<tr><td>          <i>   1 
</i><br><td>          <i>astore_2
</i><br><td><i>// Store it in local variable 2
</i>
<tr><td>          <i>   2 
</i><br><td>          <i>aload_2
</i><br><td><i>// Load local variable 2 (</i><code>f</code><i>) onto stack
</i>
<tr><td>          <i>   3 
</i><br><td>          <i>monitorenter
</i><br><td><i>// Enter the monitor associated with </i><code>f
</code>
<tr><td>          <i>   4 
</i><br><td>          <i>aload_0
</i><br><td><i>// Holding the monitor, pass </i><code>this</code><i> and
</i>
<tr><td>          <i>   5 
</i><br><td>          <i>invokevirtual 
#5 
</i><br><td><i>// call </i><code>Example.doSomething()V
</code>
<tr><td>          <i>   8
</i><br><td>          <i>aload_2
</i><br><td><i>// Load local variable 2 (</i><code>f</code><i>) onto stack
</i>
<tr><td>          <i>   9
</i><br><td>          <i>monitorexit
</i><br><td><i>// Exit the monitor associated with </i><code>f
</code>
<tr><td>          <i>  10
</i><br><td>          <i>return
</i><br><td><i>// Return normally
</i>
<tr><td>          <i>  11 
</i><br><td>          <i>aload_2
</i><br><td><i>// In case of any throw, end up here
</i>
<tr><td>          <i>  12 
</i><br><td>          <i>monitorexit
</i><br><td><i>// Be sure to exit monitor,
</i>
<tr><td>          <i>  13 
</i><br><td>          <i>athrow
</i><br><td><i>// then rethrow the value to the invoker
</i>
</Table><br><br></code><p>
<a name="23963"></a>
 <i>Exception table:</i><p><Table Border="0">
<tr><td><i>From
</i><td><i>To 
</i><td><i>Target a &#32;
</i><td><i>Type
</i>
<tr><td><i>4     
</i><td><i>8    
</i><td><i>11
</i><td><i> &#32;any
</i>
</Table><br><br><p>
<a name="23969"></a>
<p>


<hr>
<!-- This inserts footnotes--><p>
<a href="VMSpecTOC.doc.html">Contents</a> | <a href="Instructions2.doc15.html">Prev</a> | <a href="Threads.doc.html">Next</a> | <a href="Lindholm.INDEX.html">Index</a>
<p>
<font size = -1>Java Virtual Machine Specification <br>
<!--(HTML generated by dkramer on March 31, 1997)-->
<!--
(HTML generated by dkramer on March 25, 1997)-->
<br>
<i><a href="copyright.doc.html">Copyright &#169 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jvm@java.sun.com">jvm@java.sun.com</a>
</font>
</body></html>