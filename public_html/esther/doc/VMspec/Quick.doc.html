<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>VM Spec  An Optimization</title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
<table width=100%><tr>
<td><a href="VMSpecTOC.doc.html">Contents</a> | <a href="Threads.doc.html">Prev</a> | <a href="Quick2.doc.html">Next</a> | <a href="Lindholm.INDEX.html">Index</a></td><td align=right><i><i>The Java<sup><font size=-2>TM</font></sup> Virtual Machine Specification</i></i></td>
</tr></table>


<hr><br>
 
<a name="2488"></a>
<p><strong>CHAPTER 9 </strong></p>
<a name="6997"></a>
<h1>An Optimization</h1>
<hr><p>
<a name="6613"></a>
<p>
<a name="6121"></a>
This chapter describes an optimization implemented in Sun's version of the Java 
Virtual Machine. In this optimization, compiled Java Virtual Machine code is modified at run time for better performance.
<p><a name="5738"></a>
The optimization takes the form of a set of pseudo-instructions. These are variants of normal Java Virtual Machine instructions that take advantage of information learned at run time to do less work than the original instructions. The pseudo-instructions are distinguishable by the suffix <i>_quick</i> in their mnemonics.<p>
<a name="5740"></a>
It is important to understand that these pseudo-instructions are <em>not</em> part of the Java Virtual Machine specification or instruction set. They are invisible outside of a Java Virtual Machine implementation. However, inside a Java Virtual Machine implementation they have proven to be an effective optimization.<p>
<a name="2505"></a>
The technique documented in this chapter is covered by U.S. Patent 5,367,685.<p>
<a name="2984"></a>
<hr><h2>9.1	 Dynamic Linking via Rewriting</h2>
<a name="7606"></a>
A compiler targeting the Java Virtual Machine must only emit instructions from the 
instruction set documented in Chapter <a href="Instructions.doc.html#13311">6</a>, <a href="Instructions.doc.html#13312">"Java Virtual Machine Instruction Set."</a> 
The optimization described in this chapter works by dynamically replacing occurrences of certain of those instructions, the first time they are executed, by internal, 
more efficient variants. The new instructions take advantage of loading and linking 
work done the first time the associated normal instruction is executed.
<p><a name="5934"></a>
For instructions that are rewritten, each instance of the instruction is replaced on its first execution by a <i>_quick</i> pseudo-instruction. Subsequent execution of that instruction instance is always the <i>_quick</i> variant. Most instructions with <i>_quick</i> variants have just a single alternative version, although some have several.<p>
<a name="9348"></a>
In all cases, the instructions with <i>_quick</i> variants reference the constant pool, a fairly costly operation. The <i>_quick</i> pseudo-instructions save time by exploiting the fact that, while the first time an instruction referencing the constant pool must dynamically resolve the constant pool entry, subsequent invocations of that same instruction must reference the same object and need not resolve the entry again. The rewriting process is as follows:<p>
<ol>
<a name="6556"></a>
<li>Resolve the specified item in the constant pool.
<a name="6557"></a>
<li>Throw an exception if the item in the constant pool cannot be resolved. 
<a name="7629"></a>
<li>Overwrite the instruction with the <i>_quick</i> pseudo-instruction and any new operands it requires. The instructions <i>putstatic</i>, <i>getstatic</i>, <i>putfield</i>, and <i>getfield</i> each have two <i>_quick</i> versions, chosen depending on the type of the field being operated upon.
<a name="6559"></a>
<li>Execute the new <i>_quick</i> pseudo-instruction.
</ol>
<a name="9361"></a>
This is the same as the definition of the original instruction, except for the additional 
step in which the instruction overwrites itself with its <i>_quick</i> variant. The operands 
of the <i>_quick</i> pseudo-instruction must fit within the space allocated for the original 
instruction's operands.
<p><a name="9390"></a>
The <i>_quick</i> variant of an instruction can assume that the item in the constant pool has already been resolved and that this resolution did not generate any errors. It simply performs the intended operation on the resolved item. A significant amount of time is thus saved on all subsequent invocations of the pseudo-instruction.<p>
<a name="10673"></a>
<hr><h2>9.2	 The <i>_quick</i> Pseudo-instructions</h2>
<a name="5838"></a>
The remainder of this chapter specifies the <i>_quick</i> pseudo-instructions used by 
Sun's Java Virtual Machine implementation. Although they are documented in the 
same format as the normal Java Virtual Machine instructions, the <i>_quick</i> pseudo-
instructions are not part of the Java Virtual Machine specification and do not appear 
in <code>class</code> files. They are normally an invisible implementation detail, so that decisions such as opcode choices are left up to the implementor.
<p><a name="12486"></a>
However, there are exceptions to this rule. Certain tools such as debuggers and just-in-time (JIT) code generators may need to know details about the <i>_quick</i> pseudo-instructions so that they can operate on code that has already been executed. An implementation of the Java Virtual Machine may use techniques similar to but different from Sun's <i>_quick</i> pseudo-instructions, or may use different opcode numbers from Sun's implementation. Tools assuming the details of Sun's <i>_quick</i> pseudo-instructions may not work with these differing implementations.<p>
<a name="12516"></a>
APIs are being developed for debuggers and JIT code generators. These APIs may provide ways of hiding details of internal pseudo-instructions so that tools that are independent of internal implementation details can be written. However, as of this writing these APIs have not yet been established, so in the meantime we document opcode values together with other details of Sun's <i>_quick</i> instructions. Tools can assume that implementations of the Java Virtual Machine that derive from Sun's, or that are written to be compatible with Sun's implementation, will follow the specification given below.<p>
<a name="12537"></a>
Contact <code>jvm@java.sun.com</code> for more information about the status of debugger and JIT code generator APIs.<p>


<hr>
<!-- This inserts footnotes--><p>
<br>
<a href="VMSpecTOC.doc.html">Contents</a> | <a href="Threads.doc.html">Prev</a> | <a href="Quick2.doc.html">Next</a> | <a href="Lindholm.INDEX.html">Index</a>
<p>
<font size = -1>Java Virtual Machine Specification <br>
<!--(HTML generated by dkramer on March 31, 1997)-->
<!--
(HTML generated by dkramer on March 25, 1997)-->
<br>
<i><a href="copyright.doc.html">Copyright &#169 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jvm@java.sun.com">jvm@java.sun.com</a>
</font>
</body></html>