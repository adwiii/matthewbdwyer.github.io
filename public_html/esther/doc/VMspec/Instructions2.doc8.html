<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>VM Spec  </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
<table width=100%><tr>
<td><a href="VMSpecTOC.doc.html">Contents</a> | <a href="Instructions2.doc7.html">Prev</a> | <a href="Instructions2.doc9.html">Next</a> | <a href="Lindholm.INDEX.html">Index</a></td><td align=right><i><i>The Java<sup><font size=-2>TM</font></sup> Virtual Machine Specification</i></i></td>
</tr></table>


<hr><br>
 

<a name="l2d">
</a><h2>l2d</h2>
<a name="l2d.Operation"></a>
<b>Operation</h3></b>
<a name="69207"></a>
Convert <code>long</code> to <code>double</code><p><Table Border="1">
<tr><td><a name="69206"></a>
 <i>l2d</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="l2d.Forms"></a>
<b>Forms</h3></b>
<a name="69208"></a>
<i>l2d</i> = 138 (0x8a)<p>
<a name="l2d.Stack"></a>
<b>Stack</h3></b>
<a name="69209"></a>
..., <i>value.word1</i>, <i>value.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="l2d.Description"></a>
<b>Description</h3></b>
<a name="69210"></a>
The <i>value</i> on the top of the operand stack must be of type <code>long</code>. It is popped from the operand stack and converted to a <code>double</code> <i>result</i> using IEEE 754 round-to-nearest mode. The <i>result</i> is pushed onto the operand stack.<p>
<a name="l2d.Notes"></a>
<b>Notes</h3></b>
<a name="69211"></a>
The <i>l2d</i> instruction performs a widening primitive conversion <a href="Concepts.doc.html#23435">(&#167;2.6.2)</a> that may lose precision because type <code>double</code> has only 53 mantissa bits.<p>

<a name="l2f"></a>
<hr><h2>l2f</h2>
<a name="l2f.Operation"></a>
<b>Operation</h3></b>
<a name="69224"></a>
Convert <code>long</code> to <code>float</code><p><Table Border="1">
<tr><td><a name="69223"></a>
 <i>l2f</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="l2f.Forms"></a>
<b>Forms</h3></b>
<a name="69225"></a>
<i>l2f</i> = 137 (0x89)<p>
<a name="l2f.Stack"></a>
<b>Stack</h3></b>
<a name="69226"></a>
..., <i>value.word1</i>, <i>value.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i><p>
<a name="l2f.Description"></a>
<b>Description</h3></b>
<a name="69227"></a>
The <i>value</i> on the top of the operand stack must be of type <code>long</code>. It is popped from the operand stack and converted to a <code>float</code> <i>result</i> using IEEE 754 round-to-nearest mode. The <i>result</i> is pushed onto the operand stack.<p>
<a name="l2f.Notes"></a>
<b>Notes</h3></b>
<a name="69228"></a>
The <i>l2f</i> instruction performs a widening primitive conversion <a href="Concepts.doc.html#23435">(&#167;2.6.2)</a> that may lose precision because type <code>float</code> has only 24 mantissa bits.<p>
<a name="69232"></a>
<p>

<a name="l2i"></a>
<hr><h2>l2i</h2>
<a name="l2i.Operation"></a>
<b>Operation</h3></b>
<a name="69239"></a>
Convert <code>long</code> to <code>int</code><p><Table Border="1">
<tr><td><a name="69238"></a>
 <i>l2i</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="l2i.Forms"></a>
<b>Forms</h3></b>
<a name="69240"></a>
<i>l2i</i> = 136 (0x88)<p>
<a name="l2i.Stack"></a>
<b>Stack</h3></b>
<a name="69241"></a>
..., <i>value.word1</i>, <i>value.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i><p>
<a name="l2i.Description"></a>
<b>Description</h3></b>
<a name="69242"></a>
The <i>value</i> on the top of the operand stack must be of type <code>long</code>. It is popped from the operand stack and converted to an <code>int</code> <i>result</i> by taking the low-order 32 bits of the <code>long</code> value and discarding the high-order 32 bits. The <i>result</i> is pushed onto the operand stack.<p>
<a name="l2i.Notes"></a>
<b>Notes</h3></b>
<a name="69243"></a>
The <i>l2i</i> instruction performs a narrowing primitive conversion <a href="Concepts.doc.html#26142">(&#167;2.6.3)</a>. It may lose information about the overall magnitude of <i>value</i>. The <i>result</i> may also not have the same sign as <i>value</i>.<p>
<a name="69247"></a>
<p>

<a name="ladd"></a>
<hr><h2>ladd</h2>
<a name="ladd.Operation"></a>
<b>Operation</h3></b>
<a name="69254"></a>
Add <code>long</code><p><Table Border="1">
<tr><td><a name="69253"></a>
 <i>ladd</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="ladd.Forms"></a>
<b>Forms</h3></b>
<a name="69255"></a>
<i>ladd</i> = 97 (0x61)<p>
<a name="ladd.Stack"></a>
<b>Stack</h3></b>
<a name="69256"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2.word1</i>, <i>value2.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="ladd.Description"></a>
<b>Description</h3></b>
<a name="69257"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>long</code>. The values are popped from the operand stack. The <code>long</code> <i>result</i> is <i>value1</i> + <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="69258"></a>
If a <code>long</code> addition overflows, then the result is the low-order bits of the mathematical sum as represented by a <code>long</code>. If overflow occurs, then the sign of the result will not be the same as the sign of the mathematical sum of the two values.<p>
<a name="69259"></a>
<p>

<a name="laload"></a>
<hr><h2>laload</h2>
<a name="laload.Operation"></a>
<b>Operation</h3></b>
<a name="69269"></a>
Load <code>long</code> from array<p><Table Border="1">
<tr><td><a name="69268"></a>
 <i>laload</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="laload.Forms"></a>
<b>Forms</h3></b>
<a name="69270"></a>
<i>laload</i> = 47 (0x2f)<p>
<a name="laload.Stack"></a>
<b>Stack</h3></b>
<a name="69271"></a>
..., <i>arrayref</i>, <i>index</i> <img src="chars/arrwdbrt.gif"> ..., <i>value.word1</i>, <i>value.word2</i><p>
<a name="laload.Description"></a>
<b>Description</h3></b>
<a name="69272"></a>
The <i>arrayref</i> must be of type <code>reference</code> and must refer to an array whose components are of type <code>long</code>. The <i>index</i> must be of type <code>int</code>. Both <i>arrayref</i> and <i>index</i> are popped from the operand stack. The <code>long</code> <i>value</i> in the component of the array at <i>index</i> is retrieved and pushed onto the top of the operand stack.<p>
<a name="laload.Runtime"></a>
<b>Runtime Exceptions</h3></b>
<a name="69274"></a>
If <i>arrayref</i><em> </em>is <code>null</code>, <i>laload</i> throws a <code>NullPointerException</code>. <p>
<a name="69275"></a>
Otherwise, if <i>index</i> is not within the bounds of the array referenced by <i>arrayref</i>, the <i>laload</i> instruction throws an <code>ArrayIndexOutOfBoundsException</code>.<p>

<a name="land"></a>
<hr><h2>land</h2>
<a name="land.Operation"></a>
<b>Operation</h3></b>
<a name="69285"></a>
Boolean AND <code>long</code><p><Table Border="1">
<tr><td><a name="69284"></a>
 <i>land</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="land.Forms"></a>
<b>Forms</h3></b>
<a name="69286"></a>
<i>land</i> = 127 (0x7f)<p>
<a name="land.Stack"></a>
<b>Stack</h3></b>
<a name="69287"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2.word1</i>, <i>value2.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="land.Description"></a>
<b>Description</h3></b>
<a name="69288"></a>
Both <i>value1</i> and <i>value2</i> must both be of type <code>long</code>. They are popped from the operand stack. A <code>long</code> <i>result</i> is calculated by taking the bitwise AND of <i>value1</i> and <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>

<a name="lastore"></a>
<hr><h2>lastore</h2>
<a name="lastore.Operation"></a>
<b>Operation</h3></b>
<a name="69298"></a>
Store into <code>long</code> array<p><Table Border="1">
<tr><td><a name="69297"></a>
 <i>lastore</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lastore.Forms"></a>
<b>Forms</h3></b>
<a name="69299"></a>
<i>lastore</i> = 80 (0x50)<p>
<a name="lastore.Stack"></a>
<b>Stack</h3></b>
<a name="69300"></a>
..., <i>arrayref</i>, <i>index</i>, <i>value.word1</i>, <i>value.word2</i> <img src="chars/arrwdbrt.gif"> ...<p>
<a name="lastore.Description"></a>
<b>Description</h3></b>
<a name="69301"></a>
The <i>arrayref</i> must be of type <code>reference</code> and must refer to an array whose components are of type <code>long</code>. The <i>index</i> must be of type <code>int</code> and <i>value</i> must be of type <code>long</code>. The <i>arrayref</i>, <i>index</i>, and <i>value</i> are popped from the operand stack. The <code>long</code> <i>value</i> is stored as the component of the array indexed by <i>index</i>. <p>
<a name="lastore.Runtime"></a>
<b>Runtime Exceptions</h3></b>
<a name="69303"></a>
If <i>arrayref</i><em> </em>is <code>null</code>, <i>lastore</i> throws a <code>NullPointerException</code>. <p>
<a name="69304"></a>
Otherwise, if <i>index</i> is not within the bounds of the array referenced by <i>arrayref</i>, the <i>lastore</i> instruction throws an <code>ArrayIndexOutOfBoundsException</code>.<p>

<a name="lcmp"></a>
<hr><h2>lcmp</h2>
<a name="lcmp.Operation"></a>
<b>Operation</h3></b>
<a name="69311"></a>
Compare <code>long</code><p><Table Border="1">
<tr><td><a name="69310"></a>
 <i>lcmp</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lcmp.Forms"></a>
<b>Forms</h3></b>
<a name="69312"></a>
<i>lcmp</i> = 148 (0x94)<p>
<a name="lcmp.Stack"></a>
<b>Stack</h3></b>
<a name="69313"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2.word1</i>, <i>value2.word1</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i><p>
<a name="lcmp.Description"></a>
<b>Description</h3></b>
<a name="69314"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>long</code>. They are both popped from the operand stack, and a signed integer comparison is performed. If <i>value1</i> is greater than <i>value2</i>, the <code>int</code> value 1 is pushed onto the operand stack. If <i>value1</i> is equal to <i>value2</i>, the <code>int</code> value 0 is pushed onto the operand stack. If <i>value1</i> is less than <i>value2</i>, the <code>int</code> value -1 is pushed onto the operand stack.<p>

<a name="lconst_l"></a>
<hr><h2>lconst_&lt;l&gt;</h2>
<a name="lconst_l.Operation"></a>
<b>Operation</h3></b>
<a name="69321"></a>
Push <code>long</code> constant<p><Table Border="1">
<tr><td><a name="69320"></a>
 <i>lconst_&lt;l&gt;</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lconst_l.Forms"></a>
<b>Forms</h3></b>
<a name="69322"></a>
<i>lconst_0</i> = 9 (0x9)<i></i><p>
<a name="178040"></a>
<i>lconst_1</i> = 10 (0xa)<p>
<a name="lconst_l.Stack"></a>
<b>Stack</h3></b>
<a name="69323"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>&lt;l&gt;.word1</i>, <i>&lt;l&gt;.word2</i><p>
<a name="lconst_l.Description"></a>
<b>Description</h3></b>
<a name="69324"></a>
Push the <code>long</code> constant <i>&lt;l&gt;</i> (<i>0</i> or <i>1</i>) onto the operand stack. <p>

<a name="ldc"></a>
<hr><h2>ldc</h2>
<a name="ldc.Operation"></a>
<b>Operation</h3></b>
<a name="69333"></a>
Push item from constant pool<p><Table Border="1">
<tr><td><a name="69330"></a>
 <i>ldc</i>
<td><a name="87568"></a>
 

<tr><td><a name="69332"></a>
 <i>index</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="ldc.Forms"></a>
<b>Forms</h3></b>
<a name="69334"></a>
<i>ldc</i><em> </em>= 18 (0x12)<p>
<a name="ldc.Stack"></a>
<b>Stack</h3></b>
<a name="69335"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>item</i><p>
<a name="ldc.Description"></a>
<b>Description</h3></b>
<a name="69336"></a>
The <i>index</i> is an unsigned byte that must be a valid index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The constant pool entry at <i>index</i> must be a <code>CONSTANT_Integer</code> <a href="ClassFile.doc.html#21942">(&#167;4.4.4)</a>, <code>CONSTANT_Float</code> <a href="ClassFile.doc.html#21942">(&#167;4.4.4)</a>, or <code>CONSTANT_String</code> <a href="ClassFile.doc.html#8794">(&#167;4.4.3)</a>. The constant pool entry is resolved (<a href="ConstantPool.doc.html#38759">&#167;5.4</a>, <a href="ConstantPool.doc.html#49466">&#167;5.5)</a>. If the entry is a <code>CONSTANT_Integer</code> or <code>CONSTANT_Float</code>, it must contain a numeric <i>item</i> which is pushed onto the operand stack as an <code>int</code> or <code>float</code>, respectively.<p>
<a name="69352"></a>
If the entry at <i>index</i> is a <code>CONSTANT_String</code>, it must contain a <code>CONSTANT_Utf8</code> <a href="ClassFile.doc.html#7963">(&#167;4.4.7)</a> string. An instance of class <code>String</code> is created and initialized to the <code>CONSTANT_Utf8</code> string. The <i>item</i>, a <code>reference</code> to the instance, is pushed onto the operand stack.<p>
<a name="ldc.Linking"></a>
<b>Linking Exceptions</h3></b>
<a name="117410"></a>
During resolution of a <code>CONSTANT_String </code>constant pool item, any of the exceptions documented in <a href="ConstantPool.doc.html#38759">&#167;5.4</a> can be thrown.<p>

<a name="ldc_w"></a>
<hr><h2>ldc_w</h2>
<a name="ldc_w.Operation"></a>
<b>Operation</h3></b>
<a name="69366"></a>
Push item from constant pool<p><Table Border="1">
<tr><td><a name="69361"></a>
 <i>ldc_w</i>
<td><a name="87568"></a>
 

<tr><td><a name="69363"></a>
 <i>indexbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="69365"></a>
 <i>indexbyte2</i>
<td><a name="87568"></a>
 

</Table><br><br> (wide index)<p>
<a name="ldc_w.Forms"></a>
<b>Forms</h3></b>
<a name="69367"></a>
<i>ldc_w</i> = 19 (0x13)<p>
<a name="ldc_w.Stack"></a>
<b>Stack</h3></b>
<a name="69368"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>item</i><p>
<a name="ldc_w.Description"></a>
<b>Description</h3></b>
<a name="69369"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are assembled into an unsigned 16-bit index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is calculated as (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The index must be a valid index into the constant pool of the current class. The constant pool entry at the index must be a <code>CONSTANT_Integer</code> <a href="ClassFile.doc.html#21942">(&#167;4.4.4)</a>, <code>CONSTANT_Float</code> <a href="ClassFile.doc.html#21942">(&#167;4.4.4)</a>, or <code>CONSTANT_String</code> <a href="ClassFile.doc.html#8794">(&#167;4.4.3)</a>. The constant pool entry is resolved (<a href="ConstantPool.doc.html#38759">&#167;5.4</a>, <a href="ConstantPool.doc.html#49466">&#167;5.5)</a>. If the entry is a <code>CONSTANT_Integer</code> or <code>CONSTANT_Float</code>, it must contain a numeric <i>item</i> which is pushed onto the operand stack as an <code>int</code> or <code>float</code>, respectively.<p>
<a name="69385"></a>
If the entry at the constant pool index is a <code>CONSTANT_String</code>, it must contain a <code>CONSTANT_Utf8</code> <a href="ClassFile.doc.html#7963">(&#167;4.4.7)</a> string. An instance of class <code>String</code> is created and initialized to the <code>CONSTANT_Utf8</code> string. The <i>item</i>, a <code>reference</code> to the instance, is pushed onto the operand stack.<p>
<a name="ldc_w.Linking"></a>
<b>Linking Exceptions</h3></b>
<a name="117427"></a>
During resolution of a <code>CONSTANT_String </code>constant pool item, any of the exceptions documented in <a href="ConstantPool.doc.html#38759">&#167;5.4</a> can be thrown.<p>
<b>Notes</h3></b>
<a name="125478"></a>
The <i>ldc_w</i> instruction is identical to the <i>ldc</i> instruction except for its wider constant pool index.<p>

<a name="ldc2_w"></a>
<hr><h2>ldc2_w</h2>
<a name="ldc2_w.Operation"></a>
<b>Operation</h3></b>
<a name="69403"></a>
Push <code>long</code> or <code>double</code> from constant pool<p><Table Border="1">
<tr><td><a name="69398"></a>
 <i>ldc2_w</i>
<td><a name="87568"></a>
 

<tr><td><a name="69400"></a>
 <i>indexbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="69402"></a>
 <i>indexbyte2</i>
<td><a name="87568"></a>
 

</Table><br><br> (wide index)<p>
<a name="ldc2_w.Forms"></a>
<b>Forms</h3></b>
<a name="69404"></a>
<i>ldc2_w</i> = 20 (0x14)<p>
<a name="ldc2_w.Stack"></a>
<b>Stack</h3></b>
<a name="69405"></a>
... <img src="chars/arrwdbrt.gif"> ...,<em> </em><i>item.word1</i>, <i>item.word2</i><p>
<a name="ldc2_w.Description"></a>
<b>Description</h3></b>
<a name="69406"></a>
The unsigned <i>indexbyte1</i> and <i>indexbyte2</i> are assembled into an unsigned 16-bit index into the constant pool of the current class <a href="Overview.doc.html#17257">(&#167;3.6)</a>, where the value of the index is calculated as (<i>indexbyte1</i> << 8) | <i>indexbyte2</i>. The index must be a valid index into the constant pool of the current class. The constant pool entry at the index must be a <code>CONSTANT_Long</code> <a href="ClassFile.doc.html#1348">(&#167;4.4.5)</a> or <code>CONSTANT_Double</code> <a href="ClassFile.doc.html#1348">(&#167;4.4.5)</a>. The constant pool entry is resolved <a href="ConstantPool.doc.html#49466">(&#167;5.5)</a>. The entry must contain a numeric <i>item</i> which is pushed onto the operand stack as a <code>long</code> or <code>double</code>, respectively.<p>
<a name="ldc2_w.Notes"></a>
<b>Notes</h3></b>
<a name="69419"></a>
Only a wide-index version of the <i>ldc2_w</i> instruction exists; there is no <i>ldc2</i> instruction that pushes a <code>long</code> or <code>double</code> with a single-byte index.<p>

<a name="ldiv"></a>
<hr><h2>ldiv</h2>
<a name="ldiv.Operation"></a>
<b>Operation</h3></b>
<a name="69429"></a>
Divide <code>long</code><p><Table Border="1">
<tr><td><a name="69428"></a>
 <i>ldiv</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="ldiv.Forms"></a>
<b>Forms</h3></b>
<a name="69430"></a>
<i>ldiv</i> = 109 (0x6d)<p>
<a name="ldiv.Stack"></a>
<b>Stack</h3></b>
<a name="69431"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2.word1</i>, <i>value2.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="ldiv.Description"></a>
<b>Description</h3></b>
<a name="69432"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>long</code>. The values are popped from the operand stack. The <code>long</code> <i>result</i> is the value of the Java expression <i>value1</i> / <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="69433"></a>
A <code>long</code> division rounds towards 0; that is, the quotient produced for <code>long</code> values in <i>n </i>/ <i>d</i> is a <code>long</code> value <i>q</i> whose magnitude is as large as possible while satisfying <br><br><img src="Instructions2.doc.anc10.gif">
<br><br>. Moreover, <i>q </i>is positive when <br><br><img src="Instructions2.doc.anc11.gif">
<br><br> and <i>n</i> and <i>d</i> have the same sign, but <i>q</i> is negative when <br><br><img src="Instructions2.doc.anc12.gif">
<br><br> and <i>n</i> and <i>d </i>have opposite signs. <p>
<a name="69443"></a>
There is one special case that does not satisfy this rule: if the dividend is the negative integer of largest possible magnitude for the <code>long</code> type and the divisor is -<code>1</code>, then overflow occurs and the result is equal to the dividend; despite the overflow, no exception is thrown in this case. <p>
<a name="ldiv.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="69445"></a>
If the value of the divisor in a <code>long</code> division is 0, <i>ldiv</i> throws an <code>ArithmeticException</code>.<p>

<a name="lload"></a>
<hr><h2>lload</h2>
<a name="lload.Operation"></a>
<b>Operation</h3></b>
<a name="69454"></a>
Load <code>long</code> from local variable<p><Table Border="1">
<tr><td><a name="69451"></a>
 <i>lload</i>
<td><a name="87568"></a>
 

<tr><td><a name="69453"></a>
 <i>index</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lload.Forms"></a>
<b>Forms</h3></b>
<a name="69455"></a>
<i>lload</i> = 22 (0x16)<p>
<a name="lload.Stack"></a>
<b>Stack</h3></b>
<a name="69456"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>value.word1</i>, <i>value.word2</i><p>
<a name="lload.Description"></a>
<b>Description</h3></b>
<a name="69457"></a>
The <i>index</i> is an unsigned byte. Both <i>index</i> and <i>index </i>+ 1 must be valid indices into the local variables of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The local variables at <i>index</i> and <i>index </i>+ 1 together must contain a <code>long</code>. The <i>value</i> of the local variables at <i>index</i> and <i>index </i>+ 1 is pushed onto the operand stack. <p>
<a name="lload.Notes"></a>
<b>Notes</h3></b>
<a name="69461"></a>
The <i>lload</i> opcode can be used in conjunction with the <i>wide</i> instruction to access a local variable using a two-byte unsigned index.<p>

<a name="lload_n"></a>
<hr><h2>lload_&lt;n&gt;</h2>
<a name="lload_n.Operation"></a>
<b>Operation</h3></b>
<a name="69471"></a>
Load <code>long</code> from local variable<p><Table Border="1">
<tr><td><a name="69470"></a>
 <i>lload_&lt;n&gt;</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lload_n.Forms"></a>
<b>Forms</h3></b>
<a name="69472"></a>
<i>lload_0</i> = 30 (0x1e)<i></i><p>
<a name="178043"></a>
<i>lload_1</i> = 31 (0x1f)<i></i><p>
<a name="178045"></a>
<i>lload_2</i> = 32 (0x20)<i></i><p>
<a name="178047"></a>
<i>lload_3</i> = 33 (0x21)<p>
<a name="lload_n.Stack"></a>
<b>Stack</h3></b>
<a name="69473"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>value.word1</i>, <i>value.word2</i><p>
<a name="lload_n.Description"></a>
<b>Description</h3></b>
<a name="69474"></a>
Both <i>&lt;n&gt;</i> and <i>&lt;n&gt; </i>+ 1 must be valid indices into the local variables of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The local variables at <i>&lt;n&gt;</i> and <i>&lt;n&gt; </i>+ 1 together must contain a <code>long</code>. The <i>value</i> of the local variables at <i>&lt;n&gt;</i> and <i>&lt;n&gt; </i>+ 1 is pushed onto the operand stack. <p>
<a name="lload_n.Notes"></a>
<b>Notes</h3></b>
<a name="69478"></a>
Each of the <i>lload_&lt;n&gt;</i> instructions is the same as <i>lload</i> with an <i>index</i> of <i>&lt;n&gt;</i>, except that the operand <i>&lt;n&gt;</i> is implicit.<p>

<a name="lmul"></a>
<hr><h2>lmul</h2>
<a name="lmul.Operation"></a>
<b>Operation</h3></b>
<a name="69488"></a>
Multiply <code>long</code><p><Table Border="1">
<tr><td><a name="69487"></a>
 <i>lmul</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lmul.Forms"></a>
<b>Forms</h3></b>
<a name="69489"></a>
<i>lmul</i> = 105 (0x69)<p>
<a name="lmul.Stack"></a>
<b>Stack</h3></b>
<a name="69490"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2.word1</i>, <i>value2.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="lmul.Description"></a>
<b>Description</h3></b>
<a name="69491"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>long</code>. The values are popped from the operand stack. The <code>long</code> <i>result</i> is <i>value1</i> * <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="69492"></a>
If a <code>long</code> multiplication overflows, then the result is the low-order bits of the mathematical product represented as a <code>long</code>. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two values.<p>

<a name="lneg"></a>
<hr><h2>lneg</h2>
<a name="lneg.Operation"></a>
<b>Operation</h3></b>
<a name="69508"></a>
Negate <code>long</code><p><Table Border="1">
<tr><td><a name="69507"></a>
 <i>lneg</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lneg.Forms"></a>
<b>Forms</h3></b>
<a name="69509"></a>
<i>lneg</i><em> </em>= 117 (0x75)<p>
<a name="lneg.Stack"></a>
<b>Stack</h3></b>
<a name="69510"></a>
..., <i>value.word1</i><em>, </em><i>value.word2</i><em> </em><img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i><em>, </em><i>result.word2</i><p>
<a name="lneg.Description"></a>
<b>Description</h3></b>
<a name="69511"></a>
The <i>value</i> must be of type <code>long</code>. It is popped from the operand stack. The <code>long</code> <i>result</i> is the arithmetic negation of <i>value</i>, -<i>value</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="69512"></a>
For <code>long</code> values, negation is the same as subtraction from zero. Because the Java Virtual Machine uses two's-complement representation for integers and the range of two's-complement values is not symmetric, the negation of the maximum negative <code>long</code> results in that same maximum negative number. Despite the fact that overflow has occurred, no exception is thrown. <p>
<a name="69513"></a>
For all <code>long</code> values <code>x</code>, -<code>x</code> equals <code>(~x)</code> <code>+</code> <code>1</code>.<p>

<a name="lookupswitch"></a>
<hr><h2>lookupswitch</h2>
<a name="lookupswitch.Operation"></a>
<b>Operation</h3></b>
<a name="69543"></a>
Access jump table by key match and jump<p><Table Border="1">
<tr><td><a name="69522"></a>
 <i>lookupswitch</i>
<td><a name="87568"></a>
 

<tr><td><a name="69524"></a>
 <<i>0-3 byte pad</i>\>
<td><a name="87568"></a>
 

<tr><td><a name="69526"></a>
 <i>defaultbyte1</i>
<td><a name="87568"></a>
 

<tr><td><a name="69528"></a>
 <i>defaultbyte2</i>
<td><a name="87568"></a>
 

<tr><td><a name="69530"></a>
 <i>defaultbyte3</i>
<td><a name="87568"></a>
 

<tr><td><a name="69532"></a>
 <i>defaultbyte4</i>
<td><a name="87568"></a>
 

<tr><td><a name="69534"></a>
 <i>npairs1</i>
<td><a name="87568"></a>
 

<tr><td><a name="69536"></a>
 <i>npairs2</i>
<td><a name="87568"></a>
 

<tr><td><a name="69538"></a>
 <i>npairs3</i>
<td><a name="87568"></a>
 

<tr><td><a name="69540"></a>
 <i>npairs4</i>
<td><a name="87568"></a>
 

<tr><td><a name="69542"></a>
 <i>match-offset pairs</i>...
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lookupswitch.Forms"></a>
<b>Forms</h3></b>
<a name="69544"></a>
<i>lookupswitch</i> = 171 (0xab)<p>
<a name="lookupswitch.Stack"></a>
<b>Stack</h3></b>
<a name="69545"></a>
..., <i>key</i> <img src="chars/arrwdbrt.gif"> ...<p>
<a name="lookupswitch.Description"></a>
<b>Description</h3></b>
<a name="69546"></a>
A <i>lookupswitch</i> is a variable-length instruction. Immediately after the <i>lookupswitch</i> opcode, between zero and three null bytes (zeroed bytes, not the null object) are inserted as padding. The number of null bytes is chosen so that the <i>defaultbyte1</i> begins at an address that is a multiple of four bytes from the start of the current method (the opcode of its first instruction). Immediately after the padding follow a series of signed 32-bit values: <i>default</i>, <i>npairs</i>, and then <i>npairs</i> pairs of signed 32-bit values. The <i>npairs</i> must be greater than or equal to 0. Each of the <i>npairs</i> pairs consists of an <code>int</code> <i>match</i> and a signed 32-bit <i>offset</i>. Each of these signed 32-bit values is constructed from four unsigned bytes as (<i>byte1</i> << 24) | (<i>byte2</i> << 16) | (<i>byte3</i> << 8) | <i>byte4</i>.<p>

<a name="lookupswitch"></a>
<hr><h2>lookupswitch</h2>
<a name="69547"></a>
The table <i>match</i>-<i>offset</i> pairs of the <i>lookupswitch</i> instruction must be sorted in increasing numerical order by <i>match</i>.<p>
<a name="69548"></a>
The <i>key</i> must be of type <code>int</code> and is popped from the operand stack. The <i>key</i> is compared against the <i>match</i> values. If it is equal to one of them, then a target address is calculated by adding the corresponding <i>offset</i> to the address of the opcode of this <i>lookupswitch</i> instruction. If the <i>key</i> does not match any of the <i>match</i> values, the target address is calculated by adding <i>default</i> to the address of the opcode of this <i>lookupswitch</i> instruction. Execution then continues at the target address.<p>
<a name="69549"></a>
The target address that can be calculated from the offset of each <i>match-offset</i> pair, as well as the one calculated from <i>default</i>, must be the address of an opcode of an instruction within the method that contains this <i>lookupswitch</i> instruction.<p>
<a name="lookupswitch.Notes"></a>
<b>Notes</h3></b>
<a name="69550"></a>
The alignment required of the 4-byte operands of the <i>lookupswitch</i> instruction guarantees 4-byte alignment of those operands if and only if the method that contains the <i>lookupswitch</i> is positioned on a 4-byte boundary.<p>
<a name="69551"></a>
The <i>match-offset</i> pairs are sorted to support lookup routines that are quicker than linear search.<p>

<a name="lor"></a>
<hr><h2>lor</h2>
<a name="lor.Operation"></a>
<b>Operation</h3></b>
<a name="69558"></a>
Boolean OR <code>long</code><p><Table Border="1">
<tr><td><a name="69557"></a>
 <i>lor</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lor.Forms"></a>
<b>Forms</h3></b>
<a name="69559"></a>
<i>lor</i> = 129 (0x81)<p>
<a name="lor.Stack"></a>
<b>Stack</h3></b>
<a name="69560"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2.word1</i>, <i>value2.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="lor.Description"></a>
<b>Description</h3></b>
<a name="69561"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>long</code>. They are popped from the operand stack. A <code>long</code> <i>result</i> is calculated by taking the bitwise inclusive OR of <i>value1</i> and <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>

<a name="lrem"></a>
<hr><h2>lrem</h2>
<a name="lrem.Operation"></a>
<b>Operation</h3></b>
<a name="69568"></a>
Remainder <code>long</code><p><Table Border="1">
<tr><td><a name="69567"></a>
 <i>lrem</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lrem.Forms"></a>
<b>Forms</h3></b>
<a name="69569"></a>
<i>lrem</i> = 113 (0x71)<p>
<a name="lrem.Stack"></a>
<b>Stack</h3></b>
<a name="69570"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2.word1</i>, <i>value2.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="lrem.Description"></a>
<b>Description</h3></b>
<a name="69571"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>long</code>. The values are popped from the operand stack. The <code>long</code> <i>result</i> is <i>value1</i> - (<i>value1</i> / <i>value2</i>) * <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="69572"></a>
The result of the <i>lrem</i> instruction is such that <code>(a/b)*b</code> <code>+</code> <code>(a%b)</code> is equal to <code>a</code>. This identity holds even in the special case that the dividend is the negative <code>long</code> of largest possible magnitude for its type and the divisor is -<code>1</code> (the remainder is <code>0</code>). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative and can be positive only if the dividend is positive; moreover, the magnitude of the result is always less than the magnitude of the divisor. <p>
<a name="lrem.Runtime"></a>
<b>Runtime Exception</h3></b>
<a name="69574"></a>
If the value of the divisor for a <code>long</code> remainder operator is 0, <i>lrem</i> throws an <code>ArithmeticException</code>.<p>

<a name="lreturn"></a>
<hr><h2>lreturn</h2>
<a name="lreturn.Operation"></a>
<b>Operation</h3></b>
<a name="69581"></a>
Return <code>long</code> from method<p><Table Border="1">
<tr><td><a name="69580"></a>
 <i>lreturn</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lreturn.Forms"></a>
<b>Forms</h3></b>
<a name="69582"></a>
<i>lreturn</i> = 173 (0xad)<p>
<a name="lreturn.Stack"></a>
<b>Stack</h3></b>
<a name="69583"></a>
..., <i>value.word1</i>, <i>value.word2</i> <img src="chars/arrwdbrt.gif"> <p>
<a name="178050"></a>
[empty]<p>
<a name="lreturn.Description"></a>
<b>Description</h3></b>
<a name="69584"></a>
The returning method must have return type <code>long</code>. The <i>value</i> must be of type <code>long</code>. The <i>value</i> is popped from the operand stack of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a> and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded. If the returning method is a <code>synchronized</code> method, the monitor acquired or reentered on invocation of the method is released or exited (respectively) as if by execution of a <i>monitorexit</i> instruction. <p>
<a name="69588"></a>
The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.<p>

<a name="lshl"></a>
<hr><h2>lshl</h2>
<a name="lshl.Operation"></a>
<b>Operation</h3></b>
<a name="69598"></a>
Shift left<p><Table Border="1">
<tr><td><a name="69597"></a>
 <i>lshl</i>
<td><a name="87568"></a>
 

</Table><br><br> <code>long</code><p>
<a name="lshl.Forms"></a>
<b>Forms</h3></b>
<a name="69599"></a>
<i>lshl</i> = 121 (0x79)<p>
<a name="lshl.Stack"></a>
<b>Stack</h3></b>
<a name="69600"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="lshl.Description"></a>
<b>Description</h3></b>
<a name="69601"></a>
The <i>value1</i> must be of type <code>long</code> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. A <code>long</code> <i>result</i> is calculated by shifting <i>value1</i> left by <em>s</em> bit positions, where <em>s</em> is the low six bits of <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="lshl.Notes"></a>
<b>Notes</h3></b>
<a name="69602"></a>
This is equivalent (even if overflow occurs) to multiplication by 2 to the power<em> </em><em>s</em>. The shift distance actually used is therefore always in the range 0 to 63, inclusive, as if <i>value2</i> were subjected to a bitwise logical AND with the mask value 0x3f. <p>

<a name="lshr"></a>
<hr><h2>lshr</h2>
<a name="lshr.Operation"></a>
<b>Operation</h3></b>
<a name="69612"></a>
Arithmetic shift right <code>long</code><p><Table Border="1">
<tr><td><a name="69611"></a>
 <i>lshr</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lshr.Forms"></a>
<b>Forms</h3></b>
<a name="69613"></a>
<i>lshr</i> = 123 (0x7b)<p>
<a name="lshr.Stack"></a>
<b>Stack</h3></b>
<a name="69614"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="lshr.Description"></a>
<b>Description</h3></b>
<a name="69615"></a>
The <i>value1</i> must be of type <code>long</code> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. A <code>long</code> <i>result</i> is calculated by shifting <i>value1</i> right by <em>s</em> bit positions, with sign extension, where <em>s</em> is the value of the low six bits of <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="lshr.Notes"></a>
<b>Notes</h3></b>
<a name="69619"></a>
The resulting value is <br><br><img src="Instructions2.doc.anc13.gif">
<br><br>, where <i>s</i> is <i>value2</i> &amp; 0x3f. For nonnegative <i>value1</i>, this is equivalent to truncating <code>long</code> division by 2 to the power <code>s</code>. The shift distance actually used is therefore always in the range 0 to 63, inclusive, as if <i>value2</i> were subjected to a bitwise logical AND with the mask value 0x3f. <p>

<a name="lstore"></a>
<hr><h2>lstore</h2>
<a name="lstore.Operation"></a>
<b>Operation</h3></b>
<a name="69628"></a>
Store <code>long</code> into local variable<p><Table Border="1">
<tr><td><a name="69625"></a>
 <i>lstore</i>
<td><a name="87568"></a>
 

<tr><td><a name="69627"></a>
 <i>index</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lstore.Forms"></a>
<b>Forms</h3></b>
<a name="69629"></a>
<i>lstore</i> = 55 (0x37)<p>
<a name="lstore.Stack"></a>
<b>Stack</h3></b>
<a name="69630"></a>
..., <i>value.word1</i>, <i>value.word2</i> <img src="chars/arrwdbrt.gif"> ...<p>
<a name="lstore.Description"></a>
<b>Description</h3></b>
<a name="69631"></a>
The <i>index</i> is an unsigned byte. Both <i>index</i> and <i>index </i>+ 1 must be valid indices into the local variables of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The <i>value</i> on the top of the operand stack must be of type <code>long</code>. It is popped from the operand stack, and the local variables at <i>index</i> and <i>index </i>+ 1 are set to <i>value</i>. <p>
<a name="lstore.Notes"></a>
<b>Notes</h3></b>
<a name="69635"></a>
The <i>lstore</i> opcode can be used in conjunction with the <i>wide</i> instruction to access a local variable using a two-byte unsigned index.<p>

<a name="lstore_n"></a>
<hr><h2>lstore_&lt;n&gt;</h2>
<a name="lstore_n.Operation"></a>
<b>Operation</h3></b>
<a name="69645"></a>
Store <code>long</code> into local variable<p><Table Border="1">
<tr><td><a name="69644"></a>
 <i>lstore_&lt;n&gt;</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lstore_n.Forms"></a>
<b>Forms</h3></b>
<a name="69646"></a>
<i>lstore_0</i> = 63 (0x3f)<i></i><p>
<a name="178052"></a>
<i>lstore_1</i> = 64 (0x40)<i></i><p>
<a name="178054"></a>
<i>lstore_2</i> = 65 (0x41)<i></i><p>
<a name="178056"></a>
<i>lstore_3</i> = 66 (0x42)<p>
<a name="lstore_n.Stack"></a>
<b>Stack</h3></b>
<a name="88095"></a>
..., <i>value.word1</i>, <i>value.word2</i> <img src="chars/arrwdbrt.gif"> ...<p>
<a name="lstore_n.Description"></a>
<b>Description</h3></b>
<a name="69648"></a>
Both <i>&lt;n&gt;</i> and <i>&lt;n&gt; </i>+ 1 must be valid indices into the local variables of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The <i>value</i> on the top of the operand stack must be of type <code>long</code>. It is popped from the operand stack, and the local variables at <i>&lt;n&gt;</i> and <i>&lt;n&gt; </i>+ 1 are set to <i>value</i>.<p>
<a name="lstore_n.Notes"></a>
<b>Notes</h3></b>
<a name="69652"></a>
Each of the <i>lstore_&lt;n&gt;</i> instructions is the same as <i>lstore</i> with an <i>index</i> of <i>&lt;n&gt;</i>, except that the operand <i>&lt;n&gt;</i> is implicit.<p>

<a name="lsub"></a>
<hr><h2>lsub</h2>
<a name="lsub.Operation"></a>
<b>Operation</h3></b>
<a name="69662"></a>
Subtract <code>long</code><p><Table Border="1">
<tr><td><a name="69661"></a>
 <i>lsub</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lsub.Forms"></a>
<b>Forms</h3></b>
<a name="69663"></a>
<i>lsub</i> = 101 (0x65)<p>
<a name="lsub.Stack"></a>
<b>Stack</h3></b>
<a name="69664"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2.word1</i>, <i>value2.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="lsub.Description"></a>
<b>Description</h3></b>
<a name="69665"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>long</code>. The values are popped from the operand stack. The <code>long</code> <i>result</i> is <i>value1</i> - <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="69666"></a>
For <code>long</code> subtraction, <code>a</code>-<code>b</code> produces the same result as <code>a</code>+<code>(</code>-<code>b)</code>. For <code>long</code> values, subtraction from zero is the same as negation.<p>
<a name="69667"></a>
Despite the fact that overflow or underflow may occur, in which case the <i>result</i> may have a different sign than the true mathematical result, execution of an <i>lsub</i> instruction never throws a runtime exception.<p>

<a name="lushr"></a>
<hr><h2>lushr</h2>
<a name="lushr.Operation"></a>
<b>Operation</h3></b>
<a name="69677"></a>
Logical shift right <code>long</code><p><Table Border="1">
<tr><td><a name="69676"></a>
 <i>lushr</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lushr.Forms"></a>
<b>Forms</h3></b>
<a name="69678"></a>
<i>lushr</i> = 125 (0x7d)<p>
<a name="lushr.Stack"></a>
<b>Stack</h3></b>
<a name="69679"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="lushr.Description"></a>
<b>Description</h3></b>
<a name="69680"></a>
The <i>value1</i> must be of type <code>long</code> and <i>value2</i> must be of type <code>int</code>. The values are popped from the operand stack. A <code>long</code> <i>result</i> is calculated by shifting <i>value1</i> right logically (with zero extension) by the amount indicated by the low six bits of <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="lushr.Notes"></a>
<b>Notes</h3></b>
<a name="125526"></a>
If <em>value1</em> is positive and <code>s</code> is <i>value2</i> &amp; 0x3f, the result is the same as that of <i>value1</i> \>\> <code>s</code>; if <i>value1</i> is negative, the result is equal to the value of the expression (<i>value1</i> \>\> <code>s</code>) + (2L << ~<code>s</code>). The addition of the (2L << ~<code>s</code>) term cancels out the propagated sign bit. The shift distance actually used is always in the range 0 to 63, inclusive.<p>
<a name="125524"></a>
<p>

<a name="lxor"></a>
<hr><h2>lxor</h2>
<a name="lxor.Operation"></a>
<b>Operation</h3></b>
<a name="69692"></a>
Boolean XOR <code>long</code><p><Table Border="1">
<tr><td><a name="69691"></a>
 <i>lxor</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="lxor.Forms"></a>
<b>Forms</h3></b>
<a name="69693"></a>
<i>lxor</i> = 131 (0x83)<p>
<a name="lxor.Stack"></a>
<b>Stack</h3></b>
<a name="69694"></a>
..., <i>value1.word1</i>, <i>value1.word2</i>, <i>value2.word1</i>, <i>value2.word2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="lxor.Description"></a>
<b>Description</h3></b>
<a name="69695"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>long</code>. They are popped from the operand stack. A <code>long</code> <i>result</i> is calculated by taking the bitwise exclusive OR of <i>value1</i> and <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>


<hr>
<!-- This inserts footnotes--><p>
<a href="VMSpecTOC.doc.html">Contents</a> | <a href="Instructions2.doc7.html">Prev</a> | <a href="Instructions2.doc9.html">Next</a> | <a href="Lindholm.INDEX.html">Index</a>
<p>
<font size = -1>Java Virtual Machine Specification <br>
<!--(HTML generated by dkramer on March 31, 1997)-->
<!--
(HTML generated by dkramer on March 25, 1997)-->
<br>
<i><a href="copyright.doc.html">Copyright &#169 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jvm@java.sun.com">jvm@java.sun.com</a>
</font>
</body></html>
