<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>VM Spec  </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
<table width=100%><tr>
<td><a href="VMSpecTOC.doc.html">Contents</a> | <a href="Instructions2.doc4.html">Prev</a> | <a href="Instructions2.doc6.html">Next</a> | <a href="Lindholm.INDEX.html">Index</a></td><td align=right><i><i>The Java<sup><font size=-2>TM</font></sup> Virtual Machine Specification</i></i></td>
</tr></table>


<hr><br>
 

<a name="f2l">
</a><h2>f2l</h2>
<a name="f2l.Operation"></a>
<b>Operation</h3></b>
<a name="67913"></a>
Convert <code>float</code> to <code>long</code><p><Table Border="1">
<tr><td><a name="67912"></a>
 <i>f2l</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="f2l.Forms"></a>
<b>Forms</h3></b>
<a name="67914"></a>
<i>f2l</i> = 140 (0x8c)<p>
<a name="f2l.Stack"></a>
<b>Stack</h3></b>
<a name="67915"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ..., <i>result.word1</i>, <i>result.word2</i><p>
<a name="f2l.Description"></a>
<b>Description</h3></b>
<a name="67916"></a>
The <i>value</i> on the top of the operand stack must be of type <code>float</code>. It is popped from the operand stack and converted to a <code>long</code>. The <i>result</i> is pushed onto the operand stack: <p>
<ul><a name="67917"></a>
<li>If the <i>value</i> is NaN, the <i>result</i> of the conversion is a <code>long</code> 0. 
<a name="67918"></a>
<li>Otherwise, if the <i>value</i> is not an infinity, it is rounded to an integer value <i>V</i>, rounding towards zero using IEEE 754 round-towards-zero mode. If this integer value <i>V</i> can be represented as a <code>long</code>, then the <i>result</i> is the <code>long</code> value <em>V</em>.
<a name="67919"></a>
<li>Otherwise, either the <i>value</i> must be too small (a negative value of large magnitude or negative infinity), and the <i>result</i> is the smallest representable value of type <code>long</code>, or the <i>value</i> must be too large (a positive value of large magnitude or positive infinity), and the <i>result</i> is the largest representable value of type <code>long</code>.
<a name="f2l.Notes"></a>
<b>Notes</h3></b>
</ul><a name="67920"></a>
The <i>f2l</i> instruction performs a narrowing primitive conversion <a href="Concepts.doc.html#26142">(&#167;2.6.3)</a>. It may lose information about the overall magnitude of <i>value</i>, and may also lose precision.<p>

<a name="fadd"></a>
<hr><h2>fadd</h2>
<a name="fadd.Operation"></a>
<b>Operation</h3></b>
<a name="67933"></a>
Add <code>float</code><p><Table Border="1">
<tr><td><a name="67932"></a>
 <i>fadd</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="fadd.Forms"></a>
<b>Forms</h3></b>
<a name="67934"></a>
<i>fadd</i> = 98 (0x62)<p>
<a name="fadd.Stack"></a>
<b>Stack</h3></b>
<a name="67935"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i><p>
<a name="fadd.Description"></a>
<b>Description</h3></b>
<a name="67936"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>float</code>. The values are popped from the operand stack. The <code>float</code> <i>result</i> is <i>value1</i> + <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="67937"></a>
The result of an <i>fadd</i> instruction is governed by the rules of IEEE arithmetic:<p>
<ul><a name="67938"></a>
<li>If either value is NaN, the result is NaN.
<a name="67939"></a>
<li>The sum of two infinities of opposite sign is NaN.
<a name="67940"></a>
<li>The sum of two infinities of the same sign is the infinity of that sign.
<a name="67941"></a>
<li>The sum of an infinity and any finite value is equal to the infinity.
<a name="67942"></a>
<li>The sum of two zeroes of opposite sign is positive zero.
<a name="67943"></a>
<li>The sum of two zeroes of the same sign is the zero of that sign.
<a name="67944"></a>
<li>The sum of a zero and a nonzero finite value is equal to the nonzero value.
</ul>
<a name="fadd"></a>
<ul><a name="67945"></a>
<li>The sum of two nonzero finite values of the same magnitude and opposite sign is positive zero.
<a name="67946"></a>
<li>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the values have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent as a <code>float</code>, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a <code>float</code>, we say the operation underflows; the result is then a zero of appropriate sign. 
</ul><a name="67947"></a>
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of an <i>fadd</i> instruction never throws a runtime exception.<p>

<a name="faload"></a>
<hr><h2>faload</h2>
<a name="faload.Operation"></a>
<b>Operation</h3></b>
<a name="67957"></a>
Load <code>float</code> from array<p><Table Border="1">
<tr><td><a name="67956"></a>
 <i>faload</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="faload.Forms"></a>
<b>Forms</h3></b>
<a name="67958"></a>
<i>faload</i> = 48 (0x30)<p>
<a name="faload.Stack"></a>
<b>Stack</h3></b>
<a name="67959"></a>
..., <i>arrayref</i>, <i>index</i> <img src="chars/arrwdbrt.gif"> ..., <i>value</i><p>
<a name="faload.Description"></a>
<b>Description</h3></b>
<a name="67960"></a>
The <i>arrayref</i> must be of type <code>reference</code> and must refer to an array whose components are of type <code>float</code>. The <i>index</i> must be of type <code>int</code>. Both <i>arrayref</i> and <i>index</i> are popped from the operand stack. The <code>float</code> <i>value</i> in the component of the array at <i>index</i> is retrieved and pushed onto the top of the operand stack.<p>
<a name="faload.Runtime"></a>
<b>Runtime Exceptions</h3></b>
<a name="67962"></a>
If <i>arrayref</i><em> </em>is <code>null</code>, <i>faload</i> throws a <code>NullPointerException</code>. <p>
<a name="67963"></a>
Otherwise, if <i>index</i> is not within the bounds of the array referenced by <i>arrayref</i>, the <i>faload</i> instruction throws an <code>ArrayIndexOutOfBoundsException</code>.<p>

<a name="fastore"></a>
<hr><h2>fastore</h2>
<a name="fastore.Operation"></a>
<b>Operation</h3></b>
<a name="67970"></a>
Store into <code>float</code> array<p><Table Border="1">
<tr><td><a name="67969"></a>
 <i>fastore</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="fastore.Forms"></a>
<b>Forms</h3></b>
<a name="67971"></a>
<i>fastore</i> = 81 (0x51)<p>
<a name="fastore.Stack"></a>
<b>Stack</h3></b>
<a name="67972"></a>
..., <i>arrayref</i>, <i>index</i>, <i>value</i> <img src="chars/arrwdbrt.gif"> ...<p>
<a name="fastore.Description"></a>
<b>Description</h3></b>
<a name="67973"></a>
The <i>arrayref</i> must be of type <code>reference</code> and must refer to an array whose components are of type <code>float</code>. The <i>index</i> must be of type <code>int</code> and the <i>value</i> must be of type <code>float</code>. The <i>arrayref</i>, <i>index</i>, and <i>value</i> are popped from the operand stack. The <code>float</code> <i>value</i> is stored as the component of the array indexed by <i>index</i>. <p>
<a name="fastore.Runtime"></a>
<b>Runtime Exceptions</h3></b>
<a name="67975"></a>
If <i>arrayref</i><em> </em>is <code>null</code>, <i>fastore</i> throws a <code>NullPointerException</code>. <p>
<a name="67976"></a>
Otherwise, if <i>index</i> is not within the bounds of the array referenced by <i>arrayref</i>, the <i>fastore</i> instruction throws an <code>ArrayIndexOutOfBoundsException</code>.<p>

<a name="fcmpop"></a>
<hr><h2>fcmp&lt;op&gt;</h2>
<a name="fcmpop.Operation"></a>
<b>Operation</h3></b>
<a name="67986"></a>
Compare <code>float</code><p><Table Border="1">
<tr><td><a name="67985"></a>
 <i>fcmp&lt;op&gt;</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="fcmpop.Forms"></a>
<b>Forms</h3></b>
<a name="67987"></a>
<i>fcmpg</i> = 150 (0x96)<i></i><p>
<a name="177956"></a>
<i>fcmpl</i> = 149 (0x95)<p>
<a name="fcmpop.Stack"></a>
<b>Stack</h3></b>
<a name="67988"></a>
..., <i>value1</i>, <i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i><p>
<a name="fcmpop.Description"></a>
<b>Description</h3></b>
<a name="96568"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>float</code>. The values are popped from the operand stack, and a floating-point comparison is performed. If <i>value1</i> is greater than <i>value2</i>, the <code>int</code> value <i>1</i> is pushed onto the operand stack. If <i>value1</i> is equal to <i>value2</i>, the <code>int</code> value <i>0</i> is pushed onto the operand stack. If <i>value1</i> is less than <i>value2</i>, the <code>int</code> value -<i>1</i> is pushed onto the operand stack. If either <i>value1</i> or <i>value2</i> is NaN, the <i>fcmpg</i> instruction pushes the <code>int</code> value <i>1</i> onto the operand stack and the <i>fcmpl</i> instruction pushes the <code>int</code> value -<i>1</i> onto the operand stack.<p>
<a name="67990"></a>
Floating-point comparison is performed in accordance with IEEE 754. All values other than NaN are ordered, with negative infinity less than all finite values and positive infinity greater than all finite values. Positive zero and negative zero are considered equal.<p>
<a name="fcmpop.Notes"></a>
<b>Notes</h3></b>
<a name="67991"></a>
The <i>fcmpg</i> and <i>fcmpl</i> instructions differ only in their treatment of a comparison involving NaN. NaN is unordered, so any <code>float</code> comparison fails if either or both of its operands are NaN. With both <i>fcmpg</i> and <i>fcmpl</i> available, any <code>float</code> comparison may be compiled to push the same <i>result</i> onto the operand stack whether the comparison fails on non-NaN values or fails because it encountered a NaN. For more information, see <a href="Compiling.doc.html#6983">Section 7.5, "More Control Examples."</a><p>

<a name="fconst_f"></a>
<hr><h2>fconst_&lt;f&gt;</h2>
<a name="fconst_f.Operation"></a>
<b>Operation</h3></b>
<a name="68001"></a>
Push <code>float</code><code><p><Table Border="1">
<tr><td><a name="68000"></a>
 <i>fconst_&lt;f&gt;</i>
<td><a name="87568"></a>
 

</Table><br><br></code><p>
<a name="fconst_f.Forms"></a>
<b>Forms</h3></b>
<a name="68002"></a>
<i>fconst_0</i> = 11 (0xb)<i></i><p>
<a name="177958"></a>
<i>fconst_1</i> = 12 (0xc)<i></i><p>
<a name="177960"></a>
<i>fconst_2</i> = 13 (0xd)<p>
<a name="fconst_f.Stack"></a>
<b>Stack</h3></b>
<a name="68003"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>&lt;f&gt;</i><p>
<a name="fconst_f.Description"></a>
<b>Description</h3></b>
<a name="68004"></a>
Push the <code>float</code> constant <i>&lt;f&gt;</i> (<i>0.0</i>, <i>1.0</i>, or <i>2.0</i>) onto the operand stack.<p>

<a name="fdiv"></a>
<hr><h2>fdiv</h2>
<a name="fdiv.Operation"></a>
<b>Operation</h3></b>
<a name="68020"></a>
Divide <code>float</code><p><Table Border="1">
<tr><td><a name="68019"></a>
 <i>fdiv</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="fdiv.Forms"></a>
<b>Forms</h3></b>
<a name="68021"></a>
<i>fdiv</i> = 110 (0x6e)<p>
<a name="fdiv.Stack"></a>
<b>Stack</h3></b>
<a name="68022"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i><p>
<a name="fdiv.Description"></a>
<b>Description</h3></b>
<a name="68023"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>float</code>. The values are popped from the operand stack. The <code>float</code> <i>result</i> is <i>value1</i> / <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="68024"></a>
The result of an <i>fdiv</i> instruction is governed by the rules of IEEE arithmetic:<p>
<ul><a name="68025"></a>
<li>If either value is NaN, the result is NaN.
<a name="68026"></a>
<li>If neither value is NaN, the sign of the result is positive if both values have the same sign, negative if the values have different signs.
<a name="68027"></a>
<li>Division of an infinity by an infinity results in NaN.
<a name="68028"></a>
<li>Division of an infinity by a finite value results in a signed infinity, with the sign-producing rule just given.
<a name="68029"></a>
<li>Division of a finite value by an infinity results in a signed zero, with the sign-producing rule just given.
<a name="68030"></a>
<li>Division of a zero by a zero results in NaN; division of zero by any other finite value results in a signed zero, with the sign-producing rule just given.
<li>Division of a nonzero finite value by a zero results in a signed infinity, with the sign-producing rule just given.
<a name="68032"></a>
<li>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the quotient is computed and rounded to the nearest <code>float</code> using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent as a <code>float</code>, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a <code>float</code>, we say the operation underflows; the result is then a zero of appropriate sign. 
</ul><a name="68033"></a>
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, division by zero, or loss of precision may occur, execution of an <i>fdiv</i> instruction never throws a runtime exception.<p>

<a name="fload"></a>
<hr><h2>fload</h2>
<a name="fload.Operation"></a>
<b>Operation</h3></b>
<a name="68054"></a>
Load <code>float</code> from local variable<p><Table Border="1">
<tr><td><a name="68051"></a>
 <i>fload</i>
<td><a name="87568"></a>
 

<tr><td><a name="68053"></a>
 <i>index</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="fload.Forms"></a>
<b>Forms</h3></b>
<a name="68055"></a>
<i>fload</i> = 23 (0x17)<p>
<a name="fload.Stack"></a>
<b>Stack</h3></b>
<a name="68056"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>value</i><p>
<a name="fload.Description"></a>
<b>Description</h3></b>
<a name="68057"></a>
The <i>index</i> is an unsigned byte that must be a valid index into the local variables of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The local variable at <i>index</i> must contain a <code>float</code>. The <i>value</i> of the local variable at <i>index</i> is pushed onto the operand stack.<p>
<a name="fload.Notes"></a>
<b>Notes</h3></b>
<a name="68061"></a>
The <i>float</i> opcode can be used in conjunction with the <i>wide</i> instruction to access a local variable using a two-byte unsigned index.<p>

<a name="fload_n"></a>
<hr><h2>fload_&lt;n&gt;</h2>
<a name="fload_n.Operation"></a>
<b>Operation</h3></b>
<a name="68071"></a>
Load <code>float</code> from local variable<p><Table Border="1">
<tr><td><a name="68070"></a>
 <i>fload_&lt;n&gt;</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="fload_n.Forms"></a>
<b>Forms</h3></b>
<a name="68072"></a>
<i>fload_0</i> = 34 (0x22)<i></i><p>
<a name="177962"></a>
<i>fload_1</i> = 35 (0x23)<i></i><p>
<a name="177964"></a>
<i>fload_2</i> = 36 (0x24)<i></i><p>
<a name="177966"></a>
<i>fload_3</i> = 37 (0x25)<p>
<a name="fload_n.Stack"></a>
<b>Stack</h3></b>
<a name="68073"></a>
... <img src="chars/arrwdbrt.gif"> ..., <i>value</i><p>
<a name="fload_n.Description"></a>
<b>Description</h3></b>
<a name="68074"></a>
The <i>&lt;n&gt;</i> must be a valid index into the local variables of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The local variable at <i>&lt;n&gt;</i> must contain a <code>float</code>. The <i>value</i> of the local variable at <i>&lt;n&gt;</i> is pushed onto the operand stack.<p>
<a name="fload_n.Notes"></a>
<b>Notes</h3></b>
<a name="68078"></a>
Each of the <i>fload_&lt;n&gt;</i> instructions is the same as <i>fload</i> with an <i>index</i> of <i>&lt;n&gt;</i>, except that the operand <i>&lt;n&gt;</i> is implicit.<p>

<a name="fmul"></a>
<hr><h2>fmul</h2>
<a name="fmul.Operation"></a>
<b>Operation</h3></b>
<a name="68085"></a>
Multiply <code>float</code><p><Table Border="1">
<tr><td><a name="68084"></a>
 <i>fmul</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="fmul.Forms"></a>
<b>Forms</h3></b>
<a name="68086"></a>
<i>fmul</i> = 106 (0x6a)<p>
<a name="fmul.Stack"></a>
<b>Stack</h3></b>
<a name="68087"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i><p>
<a name="fmul.Description"></a>
<b>Description</h3></b>
<a name="68088"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>float</code>. The values are popped from the operand stack. The <code>float</code> <i>result</i> is <i>value1</i> * <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="68089"></a>
The result of an <i>fmul</i> instruction is governed by the rules of IEEE arithmetic:<p>
<ul><a name="68090"></a>
<li>If either value is NaN, the result is NaN.
<a name="68091"></a>
<li>If neither value is NaN, the sign of the result is positive if both values have the same sign, and negative if the values have different signs.
<a name="68092"></a>
<li>Multiplication of an infinity by a zero results in NaN.
<a name="68093"></a>
<li>Multiplication of an infinity by a finite value results in a signed infinity, with the sign-producing rule just given.
<li>In the remaining cases, where neither an infinity nor NaN is involved, the product is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent as a <code>float</code>, we say the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent as a <code>float</code>, we say the operation underflows; the result is then a zero of appropriate sign. 
</ul><a name="68095"></a>
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of an <i>fmul</i> instruction never throws a runtime exception.<p>

<a name="fneg"></a>
<hr><h2>fneg</h2>
<a name="fneg.Operation"></a>
<b>Operation</h3></b>
<a name="68108"></a>
Negate <code>float</code><p><Table Border="1">
<tr><td><a name="68107"></a>
 <i>fneg</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="fneg.Forms"></a>
<b>Forms</h3></b>
<a name="68109"></a>
<i>fneg</i> = 118 (0x76)<p>
<a name="fneg.Stack"></a>
<b>Stack</h3></b>
<a name="68110"></a>
..., <i>value</i><em> </em><img src="chars/arrwdbrt.gif"> ..., <i>result</i><p>
<a name="fneg.Description"></a>
<b>Description</h3></b>
<a name="68111"></a>
The <i>value</i> must be of type <code>float</code>. It is popped from the operand stack. The <code>float</code> <i>result</i> is the arithmetic negation of <i>value</i>, -<i>value</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="68112"></a>
For <code>float</code> values, negation is not the same as subtraction from zero. If <code>x</code> is <code>+0.0</code>, then <code>0.0-x</code> equals <code>+0.0</code>, but <code>-x</code> equals <code>-0.0</code>. Unary minus merely inverts the sign of a <code>float</code>. <p>
<a name="68113"></a>
Special cases of interest:<p>
<ul><a name="68114"></a>
<li>If the operand is NaN, the result is NaN (recall that NaN has no sign).
<a name="68115"></a>
<li>If the operand is an infinity, the result is the infinity of opposite sign.
<a name="68116"></a>
<li>If the operand is a zero, the result is the zero of opposite sign.
</ul>
<a name="frem"></a>
<hr><h2>frem</h2>
<a name="frem.Operation"></a>
<b>Operation</h3></b>
<a name="68126"></a>
Remainder <code>float</code><p><Table Border="1">
<tr><td><a name="68125"></a>
 <i>frem</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="frem.Forms"></a>
<b>Forms</h3></b>
<a name="68127"></a>
<i>frem</i> = 114 (0x72)<p>
<a name="frem.Stack"></a>
<b>Stack</h3></b>
<a name="68128"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i><p>
<a name="frem.Description"></a>
<b>Description</h3></b>
<a name="68129"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>float</code>. The values are popped from the operand stack. The <i>result</i> is calculated and pushed onto the operand stack as a <code>float</code>.<p>
<a name="68130"></a>
The <i>result</i> of an <i>frem</i> instruction is not the same that of the as the so-called remainder operation defined by IEEE 754. The IEEE 754 "remainder" operation computes the remainder from a rounding division, not a truncating division, and so its behavior is <i>not</i> analogous to that of the usual integer remainder operator. Instead, the Java Virtual Machine defines <i>frem</i> to behave in a manner analogous to that of the Java Virtual Machine integer remainder instructions (<i>irem</i> and <i>lrem</i>); this may be compared with the C library function <code>fmod</code>.<p>
<a name="68134"></a>
The result of an <i>frem</i> instruction is governed by these rules:<p>
<ul><a name="68135"></a>
<li>If either value is NaN, the result is NaN.
<a name="68136"></a>
<li>If neither value is NaN, the sign of the result equals the sign of the dividend.
<a name="68137"></a>
<li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.
<li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.
<a name="68139"></a>
<li>If the dividend is a zero and the divisor is finite, the result equals the dividend.
<a name="68140"></a>
<li>In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the floating-point remainder <i>result</i><i> </i>from a dividend <i>value1</i> and a divisor <i>value2</i> is defined by the mathematical relation <br><br><img src="Instructions2.doc.anc3.gif">
<br><br>, where <i>q</i> is an integer that is negative only if <br><br><img src="Instructions2.doc.anc4.gif">
<br><br> is negative and positive only if <br><br><img src="Instructions2.doc.anc5.gif">
<br><br> is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of <i>value1</i> and <i>value2</i>.
</ul><a name="68150"></a>
Despite the fact that division by zero may occur, evaluation of an <i>frem</i> instruction never throws a runtime exception. Overflow, underflow, or loss of precision cannot occur.<p>
<a name="frem.Notes"></a>
<b>Notes</h3></b>
<a name="68151"></a>
The IEEE 754 remainder operation may be computed by the Java library routine <code>Math.IEEEremainder</code>.<p>

<a name="freturn"></a>
<hr><h2>freturn</h2>
<a name="freturn.Operation"></a>
<b>Operation</h3></b>
<a name="68158"></a>
Return <code>float</code> from method<p><Table Border="1">
<tr><td><a name="68157"></a>
 <i>freturn</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="freturn.Forms"></a>
<b>Forms</h3></b>
<a name="68159"></a>
<i>freturn</i> = 174 (0xae)<p>
<a name="freturn.Stack"></a>
<b>Stack</h3></b>
<a name="87907"></a>
..., <i>value</i><em> </em><img src="chars/arrwdbrt.gif"> <p>
<a name="177968"></a>
[empty]<p>
<a name="freturn.Description"></a>
<b>Description</h3></b>
<a name="68161"></a>
The returning method must have return type <code>float</code>. The <i>value</i> must be of type <code>float</code>. The <i>value</i> is popped from the operand stack of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a> and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded. If the returning method is a <code>synchronized</code> method, the monitor acquired or reentered on invocation of the method is released or exited (respectively) as if by execution of a <i>monitorexit</i> instruction. <p>
<a name="68165"></a>
The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.<p>

<a name="fstore"></a>
<hr><h2>fstore</h2>
<a name="fstore.Operation"></a>
<b>Operation</h3></b>
<a name="68177"></a>
Store <code>float</code> into local variable<p><Table Border="1">
<tr><td><a name="68174"></a>
 <i>fstore</i>
<td><a name="87568"></a>
 

<tr><td><a name="68176"></a>
 <i>index</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="fstore.Forms"></a>
<b>Forms</h3></b>
<a name="68178"></a>
<i>fstore</i> = 56 (0x38)<p>
<a name="fstore.Stack"></a>
<b>Stack</h3></b>
<a name="68179"></a>
..., <i>value</i> <img src="chars/arrwdbrt.gif"> ...<p>
<a name="fstore.Description"></a>
<b>Description</h3></b>
<a name="68180"></a>
The <i>index</i> is an unsigned byte that must be a valid index into the local variables of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The <i>value</i> on the top of the operand stack must be of type <code>float</code>. It is popped from the operand stack, and the value of the local variable at <i>index</i> is set to <i>value</i>.<p>
<a name="fstore.Notes"></a>
<b>Notes</h3></b>
<a name="68184"></a>
The <i>fstore</i> opcode can be used in conjunction with the <i>wide</i> instruction to access a local variable using a two-byte unsigned index.<p>

<a name="fstore_n"></a>
<hr><h2>fstore_&lt;n&gt;</h2>
<a name="fstore_n.Operation"></a>
<b>Operation</h3></b>
<a name="68194"></a>
<p><Table Border="1">
<tr><td><a name="68193"></a>
 <i>fstore_&lt;n&gt;</i>
<td><a name="87568"></a>
 

</Table><br><br>Store <code>float</code> into local variable<p>
<a name="fstore_n.Forms"></a>
<b>Forms</h3></b>
<a name="68195"></a>
<i>fstore_0</i> = 67 (0x43)<i></i><p>
<a name="177970"></a>
<i>fstore_1</i> = 68 (0x44)<i></i><p>
<a name="177972"></a>
<i>fstore_2</i> = 69 (0x45)<i></i><p>
<a name="177974"></a>
<i>fstore_3</i> = 70 (0x46)<p>
<a name="fstore_n.Stack"></a>
<b>Stack</h3></b>
<a name="68196"></a>
..., <i>value</i><em> </em><img src="chars/arrwdbrt.gif"> ...<p>
<a name="fstore_n.Description"></a>
<b>Description</h3></b>
<a name="68197"></a>
The <i>&lt;n&gt;</i> must be a valid index into the local variables of the current frame <a href="Overview.doc.html#17257">(&#167;3.6)</a>. The <i>value</i> on the top of the operand stack must be of type <code>float</code>. It is popped from the operand stack, and the value of the local variable at <i>&lt;n&gt;</i> is set to <i>value</i>.<p>
<a name="fstore_n.Notes"></a>
<b>Notes</h3></b>
<a name="68201"></a>
Each of the <i>fstore_&lt;n&gt;</i> is the same as <i>fstore</i> with an <i>index</i> of <i>&lt;n&gt;</i>, except that the operand <i>&lt;n&gt;</i> is implicit.<p>

<a name="fsub"></a>
<hr><h2>fsub</h2>
<a name="fsub.Operation"></a>
<b>Operation</h3></b>
<a name="68208"></a>
Subtract <code>float</code><p><Table Border="1">
<tr><td><a name="68207"></a>
 <i>fsub</i>
<td><a name="87568"></a>
 

</Table><br><br><p>
<a name="fsub.Forms"></a>
<b>Forms</h3></b>
<a name="68209"></a>
<i>fsub</i> = 102 (0x66)<p>
<a name="fsub.Stack"></a>
<b>Stack</h3></b>
<a name="68210"></a>
..., <i>value1</i><em>, </em><i>value2</i> <img src="chars/arrwdbrt.gif"> ..., <i>result</i><p>
<a name="fsub.Description"></a>
<b>Description</h3></b>
<a name="68211"></a>
Both <i>value1</i> and <i>value2</i> must be of type <code>float</code>. The values are popped from the operand stack. The <code>float</code> <i>result</i> is <i>value1</i> - <i>value2</i>. The <i>result</i> is pushed onto the operand stack.<p>
<a name="68212"></a>
For <code>float</code> subtraction, it is always the case that <code>a-b</code> produces the same result as <code>a+(-b)</code>. However, for the <i>fsub</i> instruction, subtraction from zero is not the same as negation, because if <code>x</code> is <code>+0.0</code>, then <code>0.0-x</code> equals <code>+0.0</code>, but <code>-x</code> equals <code>-0.0</code>. <p>
<a name="68213"></a>
The Java Virtual Machine requires support of gradual underflow as defined by IEEE 754. Despite the fact that overflow, underflow, or loss of precision may occur, execution of an <i>fsub</i> instruction never throws a runtime exception.<p>


<hr>
<!-- This inserts footnotes--><p>
<a href="VMSpecTOC.doc.html">Contents</a> | <a href="Instructions2.doc4.html">Prev</a> | <a href="Instructions2.doc6.html">Next</a> | <a href="Lindholm.INDEX.html">Index</a>
<p>
<font size = -1>Java Virtual Machine Specification <br>
<!--(HTML generated by dkramer on March 31, 1997)-->
<!--
(HTML generated by dkramer on March 25, 1997)-->
<br>
<i><a href="copyright.doc.html">Copyright &#169 1996, 1997 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:jvm@java.sun.com">jvm@java.sun.com</a>
</font>
</body></html>
