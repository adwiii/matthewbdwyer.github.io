<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">

  <meta name="ProgId" content="FrontPage.Editor.Document">

  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <title>Compiler Construction</title>


  <link rel="stylesheet" type="text/css" href="../css/style.css">

  <meta name="Microsoft Border" content="tlb, default">

</head>


<body>

<table border="0" cellpadding="0" cellspacing="0" width="100%">

  <tbody>

    <tr>

      <td>
      <table id="AutoNumber3" style="border-collapse: collapse;" bgcolor="#ffffff" border="1" bordercolor="#0066ff" cellpadding="0" cellspacing="0" width="100%">

        <tbody>

          <tr>

            <td bordercolor="#0066FF" bordercolorlight="#0066FF" bordercolordark="#0066FF" bgcolor="#b3b3ff" width="100%">
            <p align="center"><b><font face="Arial" size="5">CSCE 425/825 - Compiler
Construction</font></b></p>

            </td>

          </tr>

        </tbody>
      </table>

      <p><span style="position: absolute; top: 50px; left: 11px;">
      <img src="../images/12x12spacer.gif" border="0" height="12" width="12"></span> </p>

      </td>

    </tr>

<!--msnavigation-->
  </tbody>
</table>

<table dir="ltr" border="0" cellpadding="0" cellspacing="0" width="100%">

  <tbody>

    <tr>

<!--#include file="sidebar.shtml" -->
      <td valign="top" width="24"></td>

<!--msnavigation--><td valign="top">
      <p><b><font face="Arial" size="5">Parsing</font></b></p>

      <h1><font face="Arial" size="2">Exercises</font></h1>

      <font face="Arial" size="2">
      </font>
      <ol>

        <font face="Arial" size="2"> <li>Define
a little language for describing finite state automata.
The language should allow you to define states and transitions
including identifying start and accept states and labeling of
transitions. Give an ANTLR spec for your language.
Implement and test your scanner/parser combination on examples 
shown in lecture and others of your choosing.
        </li>

	<li>Take the following "+" and "*" expression grammar
<pre>
E : E + E | T
T : T + T | F
F : int | ( E )
</pre>
and implement it in ANTLR.  ANTLR will tell you that 
the grammar is left-recursive.  You can eliminate
that recursion simply by replacing the left-most non-terminal in the recursive
rules with the right-hand side of the alternative production for that 
non-terminal, e.g.,
<pre>
E : T + E | T
</pre>
<ul>
<li> What does ANTLR tell you now?
<li> How can you transform the grammar to resolve this problem?
<li> What options can you enable in ANTLR to resolve the ambiguity without transforming the grammar?
<li> Does the option yield the same parse tree as the transformed grammar?
</ul>

        <li>Solve Exercises 4.2.1 in Dragon book (page 206). </li>
        <li>Solve Exercises 4.2.3 in Dragon book (page 207). </li>
        <li>Solve Exercises 4.3.1 in Dragon book (page 216). </li>
        <li>Solve Exercises 4.4.3 in Dragon book (page 231). </li>

        </font>
      </ol>

      <h1><font face="Arial" size="2">Reading</font></h1>

      <ul>

        <li><font face="Arial" size="2">ANTLR documentation</font></li>

        <li><font face="Arial" size="2">Dragon, 4.1-4.4, 4.8</font></li>

        <li><font face="Arial" size="2">StaticJava.g ANTLR spec for SJC</font></li>

      </ul>

      <p><font face="Arial" size="2"><b>Materials</b></font></p>

      <p><font face="Arial" size="2">
      <a href="resources/03-parsing.pdf">Parsing Basics</a><a href="resources/ParserTools.zip"></a>

      </font></p>

      <p><font face="Arial" size="2"><a href="resources/04-parsing-top-down.pdf">Top Down Parsing</a></font></p>

      <p><font face="Arial" size="2"><a href="resources/05-parsing-bottom-up.pdf">Bottom Up Parsing</a> (brief overview)</font></p>

      <p><font face="Arial" size="2"><a href="resources/06-antlr.pdf">ANTLR</a></font></p>

      <h1><font face="Arial" size="2"><font face="Arial" size="2"><b>Examples</b></font></font></h1>
In the compiler SVN repository, check out the project 
<em>compiler-examples</em>.  This project contains a series of 
ANTLR examples that implement different variations on the
grammars we studied in the 
<a href="resources/04-parsing-top-down.pdf">Top Down Parsing</a> 
slides.  Each example has a separate ANTLR input
and set of JUnit tests; note that these tests write their output to stdout,
which for Eclipse is the console window.
Be adventurous in modifying these examples to try different formulations
of the grammar.
<p>
Be even more adventurous in exploring the capabilities of ANTLRworks.  In particular, the Debugger is amazingly useful in helping you understand how the parse proceeds and how the parse tree is constructed.   Note that when the "backtrack" option is enabled the Interpreter mode of ANTLRworks doesn't work - but the Debugger mode still works correctly.
<p>


      <font face="Arial" size="2"><br>
      </font>
      </td>

    </tr>

  </tbody>
</table>

<br>
</body>
</html>
