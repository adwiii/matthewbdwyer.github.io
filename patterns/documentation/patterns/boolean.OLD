<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<body background="marble1.jpg">
<HEAD>
<TITLE>Boolean Combinations in/of Property Patterns</TITLE>
<META NAME="description" CONTENT="Boolean Property Pattern">
<META NAME="keywords" CONTENT="boolean existence">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
</HEAD>
<BODY LANG="EN">
<center><h1>Boolean Combinations in/of Property Patterns</h1></center>
<hr size=4>
<h1>Intent</h1>
    To describe how compound descriptions of program states/events
    can be used to parameterize property patterns and 
    to describe how independent property patterns can be combined.
<P>
<hr>

<h1>Types of Parameterization</h1>
Pattern mappings are presented in terms of place-holder symbols
(e.g. <tt><b>P,Q,R,S</b></tt>) that are to be replaced by users
when writing actual specifications.  These place holders are filled
with descriptions of specific system states or events of interest.
These descriptions can be more complex than just a single proposition
or event name.  Here are a few typical examples:
<h2>For Logics (e.g., <a href="ctl.html">CTL</a>, <a href="ltl.html">LTL</a>)</h2>
<ul>
<li> Purely propositional formula can always be used to describe a state.
This includes simple negations, disjunctions, conjunctions and implications.
<li> State-formulae that include temporal operators can also be used (e.g.,
<b>[]!init</b> responds to <b>init</b> globally would be<br>
&nbsp;&nbsp;&nbsp;&nbsp;<tt><b>[]init -> <>[]!init</b></tt>)<br>
Care must be taken in using such state-formulae, since the 
meaning of the resulting specification can be quite subtle.
</ul>

<h2>For <a href="qre.html">QREs</a></h2>
Each portion of a specification "matches" some portion of program
behavior.  This "matching", which is inherent to an automata based
specification model, means that a portion of input is consumed for
each portion of a specification.  This has some implications for
the way's that patterns can be parameterized.
<ul>
<li> Choice among a collection of events (e.g., disjunction) 
can be handled relatively simply by using symbol classes 
(e.g., <tt><b>[x,y,z]</b></tt>).
<li> Requiring a sequence of events is also simple 
(e.g., <tt><b>x;y;z</b></tt>), although such a sequence implies
that there are no intervening events in the sequence.
<li> Notions of conjunction (i.e. having all of a collection of
events occur) are significantly more complex to specify.  In this
case it is necessary to explicitly describe the possible
orderings of the constituent events (e.g., <tt><b>x;y</b></tt>,
<tt><b>y;x</b></tt>).  The same caveat about intervening events
holds here as well.
<li> Given the "matching" as consumption model of QREs, it is not
possible to "look ahead" in the computation to formulate descriptions
of certain points in the execution (e.g., as the lookahead for
<b><tt>r</tt></b> in the LTL formula
<b><tt><>r -> !q U r</tt></b> does).
</ul>
<hr>

<h1>Types of Combinations</h1>
A systems specification usually consists of a collection of 
property specifications.  

<h2>Conjunctions</h2>
It is most often the case that all
such property specifications should hold.  In this case, one
could simply check all specifications individually and require
that all are successful.  For the logical formalisms, an alternative
is to conjoin the individual specifications into a single larger
specification.
While this is semantically equivalent, it may be the case that
a larger specification is less efficient to verify (e.g., the cost of
LTL to Buchi automaton construction can be large for automata-based
model checkers).  For this reason,
preserving, and verifing, the individual property specifications is suggested.

<h2>Disjunctions</h2>
There are two views of a pair (or more generally
a collection) of alternative individual property specifications:
<ul>
<li> system behaviors <b>all</b> correspond to one specification
or they <b>all</b> correspond to the other specification

<li> <b>some</b> of the system behaviors correspond to one 
specification and the <b>rest</b> of the behaviors correspond
to the other specification
</ul>
<p>
The first of these alternatives corresponds to the checking of
individual property specifications independently and disjoining
the results.  This is true for all specification formalisms.
The latter situation can be achieved in formalisms that allow
specifications to be disjoined under the same universal path quantifier.
<p>
For LTL and QREs there is an implicit outer universal
path quantifier, thus checking of a top-level disjunction of specifications
will achieve these semantics.
To achieve the first alternative (above) one must check LTL and
QRE specifications separately.
<p>
This is not the case for CTL, where two specifications cannot
be disjoined directly under the same path quantifier.
A top-level disjunction CTL achieves the first alternative
and the second cannot be achieved directly (although one might
be able to rewrite a combined version of the two specifications).

<hr>

<h1>Examples and Known Uses</h1>
We take the view in this pattern state/event descriptions are defined
over a fixed set of state valuations/visible program actions.  It
may also be possible to control the definition of valuations/actions
For example, one could define a single proposition that is itself
defined as a a disjunction of valuations of system state variables.

<hr>

<h1>Relationships</h1>
All property patterns are parameterizable, consequently the
information in this pattern relates to all of them.
<p>
<HR size=4>
<P><ADDRESS>
<I>Matthew Dwyer</i>
</ADDRESS>
</BODY>
</HTML>
