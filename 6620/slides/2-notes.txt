What is a "trivial" property?

1) Technically that it is neither valid nor unsat for all programs
2) In addition, that it is semantic rather than syntactic, e.g., 
   does the program contain an "if" statement.

scan-build

** describe HW1

** Notes on Slides

slide 11:
 - constraints between type variables and types
 - constraints just between type variables 
 - I think these rules are incomplete
   * error

slide 12:
 - in these rules "->" is a type constructor (a function type)
 - in these rules "&" is a type constructor (a pointer type)
 - explain what "fresh" means for a variable \alpha
   - variable that is generated for each occurrence
   - the value is undefined, i.e., can be any type
 - what is this capturing for [[null]]
   - null is a value that is consistent with any pointer type
   - pointer to an int, pointer to a pointer to an int, ...

slide 13/14:
 - record types requires a reformulation to fit the unification framework
 - conceptually we combine all records declared in a program into
   a single uber-record with the union of their fields
 - a record type then partially defines instances of this uber type
   - defining the ones that it names with the designated initializers
   - defining all others as \alpha
 - then field selection just constraints the type of the named field
   and all others are \alpha
 - this requires, of course that if the same field name holds different types you will have a type error

slide 15:
 - how would you approach this?

   Generating constraint [[x:2:7]] = [[input:3:7]]
   Generating constraint [[input:3:7]] = int
   ...
   Unifying [[x:2:7]] and [[input:3:7]]
   Unifying [[input:3:7]] and int
   ...

 - Note that the transitivity of equality is encorced by unification so
   here we also get "[[x:2:7]] and int" unified

slide 16:
 - terms without variables are closed terms
 - we get terms with variables when we have something like &\tau
 - we know we have a pointer to something, but the type analysis
   hasn't yet computed the type of \tau

slide 21:
 - regular terms are generated by a regular tree grammar
 - finitely many different subtrees

slide 23:
 - this is a class of disjoint set algorithms that serve to compute
   an equivalence partition for a set, along with representatives for each
   partition 
 - you start with a forest of trivial trees, created by makeSet 
 - then you union trees to capture an equality constraint
 - there is a significant concern that unioning two trees can
   cause the resultant tree to become large or tall
 - in algorithms texts it is common to keep track of the rank/size of 
   trees and then add the lower rank/size tree to the larger to manage growth

slide 24:
 - here we don't bother with that since in practice for TIP type checking
   the type terms won't get very large

slides 26:
 - TIP has a rich type system for such a tiny language
 - it requires a more sophisticated approach than we have seen so far

*** Let's look at the related portions of the Scala implementation
 - AST
 - Types
 - TypeAnalysis.visit
 - DepthFirstVisitor
 - lots of examples to test your code on
