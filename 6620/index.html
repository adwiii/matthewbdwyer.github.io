<h1>Compilers</h1>

This is the web-site for the Spring 2020 offering of graduate-level
compilers at the University of Virginia.

<h2>Logistics</h2>
<dl>
<dt>Time</dt> <dd>Tue/Thur 15:30-16:45</dd>
<dt>Location</dt> <dd>Mech. Eng. 339</dd>
<dt>Reading</dt> <dd>No required textbook, we will work through the lecture notes developed by Anders M&oslash;ller and Michael Schwartzbach on <a href="https://cs.au.dk/~amoeller/spa/">Static Program Analysis</a> (SPA), selected research papers (see below), and code (e.g., LLVM APIs, TIP Scala)
</dl>

<h2>Expectations</h2>
This is a graduate course that will require you to learn new algorithms and implement those algorithms in multiple settings.   
This may require a degree of independence that you have not have had to practice in prior studies.
<ul>
<li> you should be familiar with compilers, e.g., through an undergrad PL or compilers course;
<li> you may need to learn new programming languages, e.g., Scala, C++11;
<li> you will have to study and understand large-scale software systems, e.g., LLVM;
<li> you will read research papers and work to understand and explain the key ideas in the papers to others; and
<li> you will work collaboratively with other students and share what you learn in class, e.g., through presentations.
</ul>
This is a course where you will learn both analytically, e.g., by reading, thinking, and discussing, and by doing, e.g., by implementing systems and evaluating them.

<h2>Grading</h2>
There will be four different kinds of assignments.
<dl>
<dt>Exercises (42%)</dt> <dd>3 programming exercises, in Scala and C++, that add functionality to the TIP compiler and implement an LLVM pass</dd>
<dt>Pass analysis (12%)</dt> <dd>read, understand, and explain an LLVM pass</dd>
<dt>Project (46%)</dt> <dd>a programming project based in LLVM that, e.g., adds features to the existing TIP compiler, extends the TIP language and compiler.</dd>
</dl>

<h2>Syllabus</h2>
The course syllabus is linked <a href="syllabus/syllabus.pdf">here</a>.

<h2>Projects</h2>
This is a list of project ideas that will provide the chance to
dig in to the details of representing, analyzing, and transforming
programs with LLVM.   These are based, primarily, on extending
the implementation of <span style="font-family:courier">tipc</span>.
<dl>

<dt>Type Checking</dt> <dd>Currently <span style="font-family:courier">tipc</span> assumes that a program has been type checked by the Scala TIP analyzer.  This project would do the type checking within <span style="font-family:courier">tipc</span> by implementing a union-find engine and the analog of TIP's type analysis.</dd>

<dt>Using Type Annotations</dt> <dd>Running Scala TIP type checker produces a type-annotated TIP program, with a <span style="font-family:courier">.ttip</span> suffix.  Currently <span style="font-family:courier">tipc</span> does not consume these annotations, but it could be extended to do so and this would pave the way for handling the rest of the TIP language, e.g., records.</dd>

<dt>Symbolic Traces</dt> <dd>TIP includes a <span style="font-family:courier">ConcolicEngine</span> which mixes execution of the program with computation of the symbolic constraints governing the execution of a path.  In this project, you will compute such symbolic constraints by instrumenting LLVM bitcodes and then emitting the constraints.  An external script can be used to generate new inputs from the constraints to drive exploration of new program paths.</dd>

<dt>Arrays</dt> <dd>TIP doesn't have these, but you can add them.  This will require extending the TIP grammar and type checker.  One approach would be to extend Scala TIP parser and type analysis and then consuming the type annotations generated in the <span style="font-family:courier">.ttip</span> file to perform code generation for array constructs.</dd>

<dt>Port Analyses</dt> <dd>TIP implements a variety of analyses, reimplement several of them as an LLVM pass applied to bitcode generated by <span style="font-family:courier">tipc</span>.  Compare your analysis results to existing LLVM analyses targetting the same problem.</dd>

<dt>Monotone Dataflow Framework</dt> <dd>Build a monotone data flow analysis framework, i.e., providing solver, lattice, and other capabilities as in TIP scala, but instead in LLVM.  Test it by building a few different analyses and compare your results to what TIP computes.</dd>  

<dt>Testing</dt> <dd>Build a CSmith-like differential testing system for TIP using <a href="https://github.com/renatahodovan/grammarinator">Grammarinator</a>; the TIP .g4 grammar makes it easy to get started.  The tricky part is ensuring that you generate TIP programs that will exercise <span style="font-family:courier">tipc</span> thoroughly.</dd>

</dl>
You will propose your project and have it accepted by me prior to 
October 28, 2019 (instructions forthcoming).  I welcome
preliminary conversations about possible projects.  Students should team up on a project since an acceptable project will require more work than one person
can reasonably complete.
It is possible for two different teams to solve the same project.

<h2>Passes</h2>
This is a list of LLVM passes that you can select to study.
Interesting studies might involve comparing two related analyses,
e.g., constant propagation vs. sparse conditional constant propagation.
These are either pure analysis passes or transformation passes
that make use of computed analysis results.
<ul>
<li>Alias Analysis
<li>Dependence Analysis
<li>Dominance Frontier
<li>Induction Variable Users
<li>Global Mod/Ref Analysis
<li>Dead Code Elimination
<li>Constant Propagation
<li>Dead Store Elimination
<li>Combine Redundant Instructions
<li>Loop Invariant Code Motion
<li>Sparse Conditional Constant Propagation
<li>Promote Memory to Register
<li>Tail Call Elimination
<li>Loop Strength Reduction
<li>Global Value Numbering
</ul>
There are many more examples listed <a href="https://llvm.org/docs/Passes.html">here</a>

<h2>Papers</h2>
Analysis papers related to LLVM, other topics mentioned in class, and a few 
"classic papers" that you can select from.  If you have another paper or topic
that you would like to study and present, let me know.
<ul>
<li><a href="https://dl.acm.org/citation.cfm?id=2737965">Alive</a> 
<li><a href="https://dl.acm.org/citation.cfm?id=3062372">Alive-Infer</a>
<li><a href="https://dl.acm.org/citation.cfm?id=36194">Superoptimization</a>
<li><a href="https://arxiv.org/abs/1711.04422">Souper</a> 
<li><a href="https://dl.acm.org/citation.cfm?id=1538814">CompCert</a>
<li><a href="https://dl.acm.org/citation.cfm?id=3192377">Crellvm</a> 
<li><a href="https://dl.acm.org/citation.cfm?id=3062343">Taming undefined behavior</a> 
<li><a href="https://dl.acm.org/citation.cfm?id=1993532">Csmith</a> 
<li><a href="https://dl.acm.org/citation.cfm?id=2594334">Equivalence modulo inputs</a> 
<li><a href="https://dl.acm.org/citation.cfm?doid=3152284.3133923">Efficient and precise alias-aware dataflow analysis</a>
<li><a href="https://dl.acm.org/citation.cfm?id=1145526">The octagon abstract domain</a>
<li><a href="https://dl.acm.org/citation.cfm?doid=3177123.3158143">Decomposing numerical abstract domains</a>
<li><a href="https://link.springer.com/chapter/10.1007/11575467_8">Program analysis implementation using datalog</a>
<li><a href="https://dl.acm.org/citation.cfm?id=2362238">Symbolically computing abstract operations </a>
<li><a href="https://dl.acm.org/citation.cfm?id=268950">Data flow analysis is model checking of abstract interpretations</a> 
<li><a href="https://dl.acm.org/citation.cfm?doid=3302515.3290361">Highly-sensitive data flow analysis using pushdown systems</a>
<li><a href="https://doi.org/10.1016/j.scico.2005.02.009">Weighted pushdown systems and their application to interprocedural dataflow analysis</a>
</ul>


<h2>Resources</h2>
Helpful resources will be posted here as the need arises.
<ul>
<li> A new Ubuntu 18.04 VM <span style="font-family:courier">cs6620.cs.virginia.edu</span> has been set up for you to use for LLVM development.  You should have an account.
<li> The <span style="font-family:courier">tipc</span> compiler is now available.  You can clone it from <a href="https://github.com/matthewbdwyer/tipc/">this</a> repository.  To install it follow the directions in the README.  Note that on <span style="font-family:courier">cs6620.cs.virginia.edu</span> you should change the line in the <span style="font-family:courier">src/CmakeLists.txt</span> file to read
<span style="font-family:courier">set(ANTLR_EXECUTABLE /usr/local/lib/antlr-4.7.2-complete.jar)</span>.
<li> On <span style="font-family:courier">portal.cs.virginia.edu</span> execute the command "<span style="font-family:courier">module load cs6620</span>" 
to get access to scala, sbt, antlr4, llvm-7, and other required software.
<li> There are discussions forums on UVACollab where you can ask questions and answer other people's questions.   I will award extra credit to those who make notable contributions to the forum at the end of the semester.
<li> Clone TIP from this <a href="https://github.com/cs-au-dk/TIP/">github repo</a>.
<li> Note that when you run tip from the command line it will mess up your terminal.  I simply type "<span style="font-family:courier">reset</span>" to get back to normal.
<li> <a href="https://docs.scala-lang.org/tutorials/">Scala tutorials</a>
</ul>

<h2>Schedule</h2>
The course will be broken into three parts: ~7 weeks of coverage of static program analysis, ~3 weeks covering static analysis in LLVM, and ~1 weeks covering code generation topics.  We will spend time working on projects.  We may adapt the schedule as we go.

<style>
table, th, td {
  padding: 15px;
  border: 1px solid black;
  border-collapse: collapse;
}
</style>
<p>
<table>
<tr> <th>Date</th> <th>Topic</th> <th>Reading</th> <th>To Do</th> </tr>
<tr> <td>01/07/20</td> <td><a href="slides/0-introduction.pdf">Class overview</a></td> <td>-</td> <td>-</td> </tr>
<tr> <td>01/09/20</td> <td><a href="slides/1-TIP.pdf">TIP</a></td> <td>read SPA 1 and 2</td> <td>-</td> </tr>
<tr> <td>01/14/20</td> <td><a href="slides/2-type-analysis.pdf">Types</a></td> <td>read SPA 3</td> 
<td><a href="hw/hw1-type-analysis">HW1 out</a></td> </tr>
<tr> <td>01/16/20</td> <td><a href="slides/3-lattices-and-fixpoints.pdf">Lattice Theory</a></td> <td>read SPA 4</td> 
<td>-</td> </tr>
<tr> <td>01/21/20</td> <td>Lattice Theory</td> <td>-</td> <td>-</td> </tr>
<tr> <td>01/23/20</td> <td>Lattice Theory</td> <td>-</td> <td>-</td> </tr>
<tr> <td>01/28/20</td> <td><a href="slides/4-flow-sensitive-analysis.pdf">Data flow analysis</a></td> <td>read SPA 5.1-5.10</td> <td><a href="hw/hw1-type-analysis">HW1 due</a> due, <a href="hw/hw2-data-flow-analysis">HW2 out</a></td> </tr>
<tr> <td>01/30/20</td> <td><a href="slides/5-widening-and-narrowing.pdf">Widening and narrowing</td> <td>read SPA 5.11-5.12</td> <td></td> </tr>
<tr> <td>02/04/20</td> <td><a href="slides/6-path-sensitivity.pdf">Path sensitive analysis</a></td> <td>read SPA 6</td> <td>-</td> </tr>
<tr> <td>02/06/20</td> <td><a href="slides/7-interprocedural-analysis.pdf">Interprocedural analysis</a></td> <td>read SPA 7</td> <td>-</td> </tr>
<tr> <td>02/11/20</td> <td><a href="slides/LLVM-part1.pdf">LLVM, <span style="font-family:courier">tipc</span>, and projects</a></td> <td>-</td> <td><a href="hw/hw2-data-flow-analysis">HW2 due</a></td> </tr>
<tr> <td>02/13/20</td> <td><a href="slides/LLVM-part2.pdf">LLVM Passes</a></td> <td></td> <td><a href="hw/hw3-llvm-pass.">HW3 out</a></td> </tr>
<tr> <td>02/18/20</td> <td><a href="slides/SSA.pdf">SSA</a></td> <td><a href="https://www.cs.princeton.edu/~appel/papers/ssafun.pdf">SSA is Functional Programming</a></td> <td>-</td> </tr>
<tr> <td>02/20/20</td> <td><a href="slides/8-control-flow-analysis.pdf">CFA</a></td> <td>read SPA 8</td> <td>-</td> </tr>
<tr> <td>02/25/20</td> <td><a href="slides/9-pointer-analysis.pdf">Pointer analysis</a></td> <td>read SPA 9</td> <td> </td> </tr>
<tr> <td>02/27/20</td> <td>Pointer Analysis</td> <td>-</td> <td><a href="hw/pass-analysis">Pass Analysis out</a></td> </tr>
<tr> <td>03/03/20</td> <td>Project Ideas</td> <td>-</td> <td>-</td> </tr>
<tr> <td>03/05/20</td> <td>Project Discussion</td> <td>-</td> <td><a href="hw/hw3-llvm-pass.">HW3 due</a></td> </tr>
<tr> <td>03/10/20</td> <td>no class (Spring Break)</td> <td>-</td> <td>-</td> </tr>
<tr> <td>03/12/20</td> <td>no class (Spring Break)</td> <td>-</td> <td>-</td> </tr>
<tr> <td>03/17/20</td> <td>Pass Presentations: ... </td> <td>-</td> <td>-</td> </tr>
<tr> <td>03/19/20</td> <td>Pass Presentations: ... </td> <td>-</td> <td>Project proposal due</td> </tr>
<tr> <td>03/24/20</td> <td>Pass Presentations: ... </td> <td>-</td> <td></td> </tr>
<tr> <td>03/26/20</td> <td>Pass Presentations: ... </td> <td>-</td> <td></td> </tr>
<tr> <td>03/31/20</td> <td>Project Meetings (Rice 424) </td> <td>-</td> <td>-</td> </tr>
<tr> <td>04/02/19</td> <td>Project Meetings (Rice 424) </td> <td>-</td> <td>-</td> </tr>
<tr> <td>04/07/19</td> <td>Project Meetings (Rice 424)</td> <td>-</td> <td>-</td> </tr>
<tr> <td>04/09/19</td> <td>Code Generation </td> <td>-</td> <td>-</td></tr>
<tr> <td>04/14/19</td> <td>Code Generation </td> <td>-</td> <td>-</td> </tr>
<tr> <td>04/16/19</td> <td>Project Presentations: ... </td> <td>-</td> <td>-</td> </tr>
<tr> <td>04/21/19</td> <td>Project Presentations: ... </td> <td>-</td> <td>-</td> </tr>
<tr> <td>04/23/19</td> <td>Project Presentations: ... </td> <td>-</td> <td>-</td> </tr>
<tr> <td>04/28/19</td> <td>Project Presentations: ... </td> <td>-</td> <td>-</td> </tr>
</table>

